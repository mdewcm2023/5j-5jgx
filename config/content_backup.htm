<h1>About</h1>
<p><a href="https://www.nbcnewyork.com/news/recall-alert/2-2-million-peloton-exercise-bikes-recalled-immediately-stop-using-govt-says/4324576/">https://www.nbcnewyork.com/news/recall-alert/2-2-million-peloton-exercise-bikes-recalled-immediately-stop-using-govt-says/4324576/</a> </p>
<p><a href="https://www.techspot.com/news/98625-dram-ssds-continue-get-cheaper-coming-months.html">https://www.techspot.com/news/98625-dram-ssds-continue-get-cheaper-coming-months.html</a> </p>
<p><a href="https://abcnews.go.com/GMA/Living/17-year-set-graduate-3-college-degrees-hs/story?id=99103751&amp;cid=social_twitter_abcn">https://abcnews.go.com/GMA/Living/17-year-set-graduate-3-college-degrees-hs/story?id=99103751&amp;cid=social_twitter_abcn</a> </p>
<p><a href="https://www.utilitydive.com/news/efficiency-standards-electric-motors-doe-dishwasher/649954/">https://www.utilitydive.com/news/efficiency-standards-electric-motors-doe-dishwasher/649954/</a> </p>
<p><span style="background-color: #ffff00;">精密機械設計工程師的三個電腦網路與程式端: 近端、中端與遠端</span>.</p>
<ol>
<li>近端帶有各種可攜帶且開源的程式套件與工具 (能編譯 C, C++, 解譯 Javascript, Python 與 Lua 的 USB 隨身碟或筆電系統)</li>
<li>中端即工作站室, 其中包含各種自行安裝配置的虛擬電腦主機 (Windows and Linux servers)</li>
<li>遠端即雲端, 其中包含各大公司所提供的免費或付費服務 (Github, Onedrive, Repllit, Azure, AWS)</li>
</ol>
<hr/>
<p>2009 年啟用的電腦配置 8GB 安裝 Ubuntu 22.04 操作系統, 以 Nginx 伺服靜態系統, 以 wsgi 伺服動態系統.</p>
<p>Repo: <a href="https://github.com/mdewcm2023/5j-5jgx">https://github.com/mdewcm2023/5j-5jgx</a></p>
<p>site: <a href="https://mdewcm2023.github.io/5j-5jgx">https://mdewcm2023.github.io/5j-5jgx</a></p>
<p>on cad2: <a href="http://cad2.cycu.org/~yen/5jgx/">http://cad2.cycu.org/~yen/5jgx/</a></p>
<p>on cad2 account jgx: <a href="http://cad2.cycu.org/~jgx/5jgx">http://cad2.cycu.org/~jgx/5jgx</a></p>
<p><a href="https://nfuedu-my.sharepoint.com/:v:/g/personal/yen_nfu_edu_tw/EZ1mSm2ZZMRLmA1Bt_KHGHwBOOS3TVIIF90Ehz6p0UI9vA?e=dad4VR">w11 如何在 cad2 主機上建立各分組的靜態網站.mp4</a></p>
<p>on cad2: <a>https://cad2.cycu.org:8001</a> from hupper -m server.py</p>
<p>ssh-keygen: <a href="https://mde.tw/blog/2022_fall_courses_w10.html">https://mde.tw/blog/2022_fall_courses_w10.html</a></p>
<p>sudo apt install ncat</p>
<p>SSH setup:</p>
<p>.ssh/config</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">Host github.com
User git
Hostname github.com
ProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p</pre>
<p>need to chmod u+x ./acp</p>
<p></p>
<h2>精密機械</h2>
<p><a href="https://github.com/KmolYuan">學長</a> <a href="https://asmedigitalcollection.asme.org/IDETC-CIE/proceedings/IDETC-CIE2021/85444/V08AT08A015/1128605">2021 年發表的論文</a></p>
<p><span dir="ltr" role="presentation" style="left: 26.35%; top: 15.64%; font-size: calc(var(--scale-factor)*14.35px); font-family: sans-serif; transform: scaleX(0.978194);"><a href="https://hal.science/hal-02874107/document">Appropriate Synthesis of the Four-Bar Linkage</a></span></p>
<p><span dir="ltr" role="presentation" style="left: 26.35%; top: 15.64%; font-size: calc(var(--scale-factor)*14.35px); font-family: sans-serif; transform: scaleX(0.978194);"><a href="https://www.researchgate.net/publication/329077088_Synthesis_of_precision_flexible_mechanisms_using_screw_theory_and_beam_constraints">Synthesis of precision flexible mechanisms using screw theory and beam constraints</a></span></p>
<h3>程式開發</h3>
<p><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EUd5wZF9jSdCtrDkLvEfyj4Bq8pkV0b3kKZ1fxeNMhC8qg?e=slvduQ">下載 MSYS2 and Cmake.7z</a> (下載 3.47GB 解開後 12.6GB, for @nfu users only)</p>
<p>在計算機程式開發過程中學習英文、演算法、資料結構與資料庫 (SQLite and PostgreSQL)</p>
<p style="padding-left: 30px;"><a href="https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf">Data structures and algorithms</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-0055-1">Python Algorithms</a> (for @nfu users only)</p>
<p style="padding-left: 30px;"><a href="https://www.cs.auckland.ac.nz/courses/compsci105ssc/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf">Problem Solving with Algorithms and Data Structures</a></p>
<p>Javascript (在瀏覽器中學習)</p>
<p>Python (Brython) - 以 Brython 接續 Javascript 在網頁中用 Brython 解題, 透過網路與 Server 端的 Python 程式互動, 而 Server 端的 Python 則可再與 MCAD API 互動 (SolidWorks, Solid Edge, NX 等)</p>
<p>ANSIC (Arduino) - 從 Arduino 硬體控制 C 程式學習與 Server 端的 Python 程式整合</p>
<p>C++ (Solvespace) - 自行編譯 Solvespace, 建立 dll 與 Python 互動, 導入 Pyslvs-UI</p>
<p>Lua (CoppeliaSim) - 虛實整合模擬與控制系統設計平台</p>
<p>MSYS2 與 Cmake - C 與 C++ 編譯器</p>
<hr/>
<p>以 MSYS2 編譯 lua 原始碼: </p>
<p>REM 設定 msys2 64 位元的執行路徑<br/>set path_msys2=%Disk%:\msys64_20210419\mingw64\bin;</p>
<p>Lua 原始碼 - 以 ANSI C 編寫</p>
<p>下載後解開壓縮檔案, 進入原始碼目錄後執行:</p>
<p style="padding-left: 30px;">make PLAT=mingw</p>
<p>即可在 src 目錄中取得 lua.exe, luac.exe, lua53.dll 以及 liblua.a (以 lua 5.3.5 為例)</p>
<hr/>
<p>因為 CoppeliaSim 透過 simExtWS.dll (Websocket extension server), simAddonVisualization stream.lua 以及 threejsFrontend.js 讓使用者可以在啟動 Visualization stream 伺服器後, 由瀏覽器的特定 port (內定為 23020) 取得 threejsFrontend.html 頁面 client 程式與 server 端傳遞場景模擬串流資料, 可以讓多人即時觀看場景模擬.</p>
<p>內建的 simAddonVisualization stream.lua 僅讓 client 端以 HTTP request 場景物件串流資料 (即透過 ws:// 發出 requests), 若要讓 client 以 HTTPS request 發出 requests (即改透過 wss://), 則 simAddonVisualization stream.lua 必須建立 SSL 架構的 server, 這時就需要 Lua 帶有 ssl 或 luasec 模組才行.</p>
<p>因此自行編譯 lua 原始碼的用意即在設法根據需求延伸 CoppeliaSim 的功能.</p>
<h2>Javascript</h2>
<p>The best way to learn Javascript:<br/><br/>Learning JavaScript is a great way to get started with web development, as it is a powerful and versatile programming language used in many different applications. Here are some tips on how to learn JavaScript effectively:<br/><br/>1. Start with the basics: Before diving into complex frameworks or libraries, make sure you have a solid foundation of the basics of JavaScript. This includes understanding variables, data types, functions, loops, and conditional statements.<br/><br/>2. Practice coding: The best way to learn JavaScript is to practice coding. This means writing your own code, working on exercises and projects, and experimenting with different concepts.<br/><br/>3. Use online resources: There are many online resources available for learning JavaScript, including video tutorials, online courses, and documentation. Some popular options include Codecademy, FreeCodeCamp, and Mozilla Developer Network.<br/><br/>4. Join a community: Joining a community of JavaScript learners can be helpful for getting support and feedback on your code, as well as learning from others. You can join online communities such as Stack Overflow, Reddit, or GitHub.<br/><br/>5. Build projects: Building projects is a great way to apply what you've learned and gain practical experience with JavaScript. Start with small projects and gradually increase the complexity as you become more comfortable with the language.<br/><br/>6. Keep learning: JavaScript is constantly evolving, so it's important to stay up to date with the latest updates and trends. Subscribe to newsletters, follow blogs and podcasts, and attend conferences to continue your learning journey.<br/><br/>To have a solid foundation of the basics of JavaScript, you can follow these steps:<br/><br/>1. Read the documentation: Start by reading the official documentation for JavaScript. This will give you a thorough understanding of the language's syntax, data types, functions, and more. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide">The Mozilla Developer Network has an excellent JavaScript Guide</a> that covers all the basics.<br/><br/>2. Follow a structured course: Online courses, such as Codecademy or FreeCodeCamp, can provide a structured way to learn the basics of JavaScript. These courses often include interactive exercises and projects to help you practice what you've learned.<br/><br/>3. Practice coding: To solidify your understanding of the basics, you need to practice coding. You can start by writing simple programs that utilize variables, data types, functions, loops, and conditional statements. As you practice, gradually increase the complexity of your programs.<br/><br/>4. Review code examples: Reading and analyzing code examples can help you understand how the basics of JavaScript are used in practice. You can find examples on websites like GitHub or by reading through the source code of popular JavaScript libraries and frameworks.<br/><br/>5. Get feedback: Getting feedback on your code from other developers can help you identify areas for improvement and solidify your understanding of the basics. Joining online communities, like Stack Overflow, can be a good way to get feedback on your code and ask questions.</p>
<p>References:</p>
<p style="padding-left: 30px;"><a href="https://eloquentjavascript.net/">https://eloquentjavascript.net/</a></p>
<p style="padding-left: 30px;"><a href="http://jsforcats.com/">http://jsforcats.com/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/getify/You-Dont-Know-JS">https://github.com/getify/You-Dont-Know-JS</a></p>
<h2>TOEIC</h2>
<p>多益（TOEIC）是一種用於測試非英語為母語人士英語語言能力的標準化考試。它是由ETS（Educational Testing Service）組織開發的，旨在評估考生的英語聽力和閱讀能力，用於在全球範圍內衡量英語語言能力。<br/><br/>多益考試分為兩個部分：聽力和閱讀。聽力部分包括聆聽錄音並回答問題，閱讀部分包括閱讀文章並回答問題。考試時間為2小時，總分為990分，聽力和閱讀各佔50%。<br/><br/>多益考試通常用於衡量非英語國家的學生、畢業生和職業人士的英語水平。許多公司和學校使用多益考試作為聘請和錄取員工和學生的標準，以衡量他們的英語水平。</p>
<p>TOEIC 代表 "Test of English for International Communication"，翻譯成中文是「國際英語溝通測驗」。</p>
<p>TOEIC 包含兩種題型：單選題和填充題。其中，閱讀部分是以單選題為主，聽力部分則是以填充題和單選題結合的形式出現。閱讀部分的單選題是選出最適合或最相符的答案，填充題是根據題目要求填入適當的單詞或短語。聽力部分的填充題是根據所聽到的對話或短文內容填空，單選題是選出最適合或最相符的答案。</p>
<p>TOEIC 的選擇題不會有倒扣，也就是說，考生選擇了錯誤的答案不會扣除分數。每個題目都有唯一正確的答案，考生選擇了正確的答案可以得到相應的分數，選擇了錯誤的答案則不會得分。因此，建議考生如果對一道題目不確定答案，也可以根據猜測選擇一個選項，以增加得分的機會。</p>
<h2>nginx</h2>
<p>設定 public_html</p>
<p><a href="https://www.server-world.info/en/note?os=Ubuntu_20.04&amp;p=nginx&amp;f=4">https://www.server-world.info/en/note?os=Ubuntu_20.04&amp;p=nginx&amp;f=4</a></p>
<p>r: 4, w: 2, x: 1</p>
<p>外部 711 - user rwx, group x, other x</p>
<p>public_html 755 - user rwx, group rx, other rx</p>
<p></p>
<p></p>
<h2>Downloads</h2>
<p>OBS: <a href="https://obsproject.com/download">https://obsproject.com/download</a></p>
<p>Virtualbox: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p>
<p><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EV5lw40RXvNFue1Cr2sivioBuOj_QA5KzAxDMU0Mkf7z8w?e=NtOJeN">wcm_portable_w2-5.7z</a> (下載 220MB 解開後 880MB)</p>
<h2>OBS</h2>
<p>由於 OBS 會將 setting 存入 AppData 目錄, 因此要在隨身碟中保有先前的設定, 必須透過可攜系統的 command 啟動 obs.</p>
<p>議題: 如何設定鍵盤快捷鍵, 讓啟動與關閉錄影過程不會顯示在錄製的影片中.</p>
<p>議題: 手機可以做為 OBS 的一個 camera 來源嗎?</p>
<p>議題: OBS 可以透過 Youtube 或其他雲端網站進行 live streaming (現場串流直播)</p>
<p>利用程式控制 OBS:</p>
<p style="padding-left: 30px;"><a href="https://docs.obsproject.com/scripting">https://docs.obsproject.com/scripting</a></p>
<p></p>
<h1>cmsimde</h1>
<h2>Upload</h2>
<p><img alt="" height="300" src="/images/網際內容管理五月五日留念.jpg" width="400"/></p>
<p><img alt="" height="711" src="/images/托福考試.png" width="400"/></p>
<p></p>
<p><img alt="" height="711" src="/images/GRE測驗.png" width="400"/></p>
<p>準備在 Server 端加上 image files rename 功能.</p>
<p>Since the resolution of mobile phone camera is quite high, in order to get the resonable resolution images file upload for cmsimde based CMS, image files needed to reduce before uploading.</p>
<p>Add the following functions to axuploader.js:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">// Function to resize an image
function resizeImage(file, maxWidth, callback) {
  // Create a new FileReader object
  const reader = new FileReader();

  // Add an event listener to the FileReader object that listens for when the file is loaded
  reader.addEventListener("load", () =&gt; {
    // Create a new image object
    const img = new Image();

      // Add an event listener to the image object that listens for when the image is loaded
      img.addEventListener("load", () =&gt; {
      var ratio = Math.min(maxWidth / img.width);
      // Create a new canvas object
      const canvas = document.createElement("canvas");

      // Set the canvas width and height to the new width and height of the image
	  canvas.width = img.width * ratio;
	  canvas.height = img.height * ratio;

      // Draw the image onto the canvas with the new width and height
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      // Convert the canvas to a data URL
      const dataUrl = canvas.toDataURL("image/jpeg");

      // Create a new file object from the data URL
      const resizedFile = dataURLtoFile(dataUrl, file.name);

      // Return the resized file
      callback(resizedFile);
    });

    // Set the source of the image object to the data URL of the file
    img.src = reader.result;
  });

  // Read the file as a data URL
  reader.readAsDataURL(file);
}

// Function to convert a data URL to a file object
function dataURLtoFile(dataUrl, filename) {
  const arr = dataUrl.split(",");
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, { type: mime });
}</pre>
<h2>ax5</h2>
<p>using ax5:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">var uploader = new ax5.ui.uploader({
  target: $('[data-ax5uploader="basic"]'),
  form: {
    action: "/upload",
    fileName: "file"
  },
  multiple: true,
  manualUpload: true,
  onprogress: function () {},
  onuploaderror: function () {},
  onuploaded: function () {}
});

uploader.on('beforeUpload', function () {
  var files = uploader.getFiles();
  for (var i = 0; i &lt; files.length; i++) {
    var file = files[i];
    var extension = file.name.split('.').pop().toLowerCase();
    if (extension == 'jpg' || extension == 'png' || extension == 'gif') {
      var img = new Image();
      img.src = window.URL.createObjectURL(file);
      img.onload = function () {
        if (this.width &gt; 800) {
          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var ratio = 800 / this.width;
          canvas.width = this.width * ratio;
          canvas.height = this.height * ratio;
          ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
          canvas.toBlob(function (blob) {
            file = new File([blob], file.name, {type: file.type});
          });
        }
      };
    }
  }
});
</pre>
<p>html side:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;My Web Application&lt;/title&gt;
	&lt;!-- include ax5 library from CDN --&gt;
	&lt;script src="https://cdn.rawgit.com/ax5ui/ax5core/master/dist/ax5core.min.js"&gt;&lt;/script&gt;
	&lt;script src="https://cdn.rawgit.com/ax5ui/ax5ui-datepicker/master/dist/ax5ui-datepicker.min.js"&gt;&lt;/script&gt;
	&lt;link rel="stylesheet" href="https://cdn.rawgit.com/ax5ui/ax5ui-datepicker/master/dist/ax5ui-datepicker.css"&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;!-- your web application content goes here --&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>ax5 works with Brython:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, alert
import ax5.ui.datepicker as datepicker

# create a datepicker component
dp = datepicker.create(
  document["datepicker"],
  {"mode": "date", "selectMode": "day", "control": {"left": "&lt;", "yearTmpl": "%s", "monthTmpl": "%s"}},
  {"onStateChanged": lambda e: alert(e["state"]["focusedDate"])},
  {"minDate": "2020-01-01", "maxDate": "2023-12-31", "defaultDate": "2023-04-27"}
)

# show the datepicker component when the button is clicked
def show_datepicker(ev):
  dp.popup()

document["btn-show-datepicker"].bind("click", show_datepicker)
</pre>
<p>html side:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;My Brython App&lt;/title&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/brython@3.9.12/brython.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/ax5core@1.12.2/dist/ax5core.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/ax5ui-datepicker@1.0.1/dist/ax5ui-datepicker.min.js"&gt;&lt;/script&gt;
  &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ax5ui-datepicker@1.0.1/dist/ax5ui-datepicker.css"&gt;
&lt;/head&gt;
&lt;body onload="brython()"&gt;
  &lt;button id="btn-show-datepicker"&gt;Show Datepicker&lt;/button&gt;
  &lt;div id="datepicker"&gt;&lt;/div&gt;
  &lt;script type="text/python"&gt;
    # your Python code goes here
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Create pull-down menu by using ax5 and Brython:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, alert
import ax5.ui.menu as menu

# define the menu items
menu_items = [
    {"label": "Item 1", "value": "item1"},
    {"label": "Item 2", "value": "item2"},
    {"label": "Item 3", "value": "item3"},
    {"label": "Item 4", "value": "item4"}
]

# create the menu component
m = menu.create(
    document["menu"],
    {"theme": "default", "direction": "auto", "offset": {"left": 0, "top": 0}},
    {"onSelect": lambda e: alert(e["selected"])},
    menu_items
)

# show the menu component when the button is clicked
def show_menu(ev):
    m.popup()

document["btn-show-menu"].bind("click", show_menu)
</pre>
<p>html side:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My Brython App&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/brython@3.9.12/brython.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/ax5core@1.12.2/dist/ax5core.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/ax5ui-menu@1.0.7/dist/ax5ui-menu.min.js"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ax5ui-menu@1.0.7/dist/ax5ui-menu.css"&gt;
&lt;/head&gt;
&lt;body onload="brython()"&gt;
    &lt;button id="btn-show-menu"&gt;Show Menu&lt;/button&gt;
    &lt;div id="menu"&gt;&lt;/div&gt;
    &lt;script type="text/python"&gt;
        # your Python code goes here
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Using axios:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, ajax
import axios

# function to handle form submission
def submit_form(ev):
    ev.preventDefault()  # prevent default form submission
    form_data = FormData(document["my-form"])  # create FormData object from form
    axios.post("/submit", data=form_data)  # send form data to Flask server

document["my-form"].bind("submit", submit_form)
</pre>
<p>Flask side:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, request

app = Flask(__name__)

@app.route('/submit', methods=['POST'])
def submit():
    file = request.files['file']  # get the file object from the request
    # process the file object here
    return 'File uploaded successfully'

if __name__ == '__main__':
    app.run()
</pre>
<p>Using axios and Brython to GET:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import axios

axios.get('https://api.example.com/data')
    .then(function(response) {
        console.log(response.data);
    })
    .catch(function(error) {
        console.error(error);
    });
</pre>
<p>axios and traditional XMLHttpRequest (XHR) (also known as AJAX) are both ways to make HTTP requests in JavaScript. While both can be used to accomplish similar tasks, axios provides a number of advantages over traditional AJAX:</p>
<ol>
<li>Promise-based API: axios uses a promise-based API, which makes it easier to manage asynchronous code and handle errors.</li>
<li>Automatic request cancellation: axios allows you to cancel requests that are in progress, which can help to improve performance and reduce network traffic.</li>
<li>Intercepting requests and responses: axios allows you to intercept requests and responses, which can be useful for adding authentication headers, logging, or modifying requests or responses.</li>
<li>Support for Cross-site requests: axios includes built-in support for cross-site requests (CSRF) protection, which is important for security when making requests to a different domain than the one hosting the page.</li>
<li>Simpler syntax: axios provides a simpler and more consistent API for making requests than traditional AJAX.</li>
</ol>
<p>Overall, axios provides a more modern and convenient way to make HTTP requests than traditional AJAX, and is widely used and well-documented. However, there are still situations where traditional AJAX may be more appropriate, depending on the specific requirements of your application.</p>
<p>axios was developed by Matt Zabriskie, a web developer based in New York City. It was originally released in 2014 as an alternative to the jQuery.ajax() function, and has since become a popular library for making HTTP requests in JavaScript applications.<br/><br/>The project is open source and hosted on GitHub, where it is maintained by a community of contributors. The library is licensed under the MIT license, which allows for free use and modification of the code in both open source and commercial projects.</p>
<h2>Games</h2>
<p>Learn Python and Javascript:</p>
<p style="padding-left: 30px;">Python:</p>
<p style="padding-left: 60px;"><a href="/downloads/python_beginners.pdf">python_beginners.pdf</a></p>
<p style="padding-left: 60px;"><a href="file:///C:/Users/admin/Downloads/978-1-4842-7058-5.pdf">Programming Microcontrollers with Python</a> (2021) (必須使用校園網路(Proxy or VPN) 才能下載)</p>
<p style="padding-left: 60px;"><a href="file:///C:/Users/admin/Downloads/978-1-4302-6425-5.pdf">Learn Raspberry Pi Programming with Python</a> (2014) (必須使用校園網路(Proxy or VPN) 才能下載)</p>
<p style="padding-left: 30px;">Javascript:</p>
<p style="padding-left: 60px;"><a href="file:///C:/Users/admin/Downloads/978-1-4842-7377-7-2.pdf">Build Your Own 2D Game Engine and Create Great Web Games</a> (2022) (必須使用校園網路(Proxy or VPN) 才能下載)</p>
<p>Brython: <a href="https://brython.info/">https://brython.info/</a></p>
<p style="padding-left: 30px;"><a href="https://brython.info/gallery/bricks_py.html">https://brython.info/gallery/bricks_py.html</a></p>
<p style="padding-left: 30px;"><a href="https://brython.info/gallery/3Dwalker.html">https://brython.info/gallery/3Dwalker.html</a></p>
<p style="padding-left: 30px;"><a href="https://bmsleight.github.io/brython-blocks/">https://bmsleight.github.io/brython-blocks/</a></p>
<p style="padding-left: 30px;"><a href="https://brython.info/gallery/taquin.html">https://brython.info/gallery/taquin.html</a></p>
<p><a href="https://github.com/BrythonServer/ggame">https://github.com/BrythonServer/ggame</a></p>
<p><a href="https://mde.tw/wcm2023/content/Reeborg.html">https://mde.tw/wcm2023/content/Reeborg.html</a></p>
<h1>Note</h1>
<p><a href="https://github.com/paroga/cbor-js">https://github.com/paroga/cbor-js</a> </p>
<p><a href="https://github.com/uuidjs/uuid">https://github.com/uuidjs/uuid</a> </p>
<p><a href="https://github.com/zeromq/zeromq.js/">https://github.com/zeromq/zeromq.js/</a> </p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1});
}
</script>
<script type="text/python">
from browser import document, console, window

# Define the CoppeliaSim connection parameters
host = '127.0.0.1'
port = 23000

# Connect to CoppeliaSim
def connect():
    window.simulator = window.BVRemoteAPI.connect(host, port)
    if window.simulator.is_connected():
        console.log('Connected to CoppeliaSim')
    else:
        console.log('Failed to connect to CoppeliaSim')

# Disconnect from CoppeliaSim
def disconnect():
    if hasattr(window, 'simulator') and window.simulator.is_connected():
        window.simulator.disconnect()
        console.log('Disconnected from CoppeliaSim')

# Send a command to CoppeliaSim and get the response
def send_command(command):
    if hasattr(window, 'simulator') and window.simulator.is_connected():
        res, ret_ints, ret_floats, ret_strings, ret_buffer = window.simulator.simxCallScriptFunction(
            '', window.simulator.sim_scripttype_childscript, 'pyrep', command, [], [], [], '')
        if res == 0:
            console.log('Command executed successfully')
            return ret_strings[0]  # Assuming a string response
        else:
            console.log('Failed to execute command:', res)
    else:
        console.log('Not connected to CoppeliaSim')

# Example usage
connect()
response = send_command('simGetObjectName(0)')
console.log('Response:', response)
disconnect()
</script>
</p><h2>Windows</h2>
<p>Microsoft Terminal Service Client: mstsc</p>
<h2>w13</h2>
<p><a href="https://mde.tw/cd2023/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/21cd96ab42159807ac5b6db2440d3e6c/raw/a8cc303b51022324d7319c64720fb54eb59b2ea7/list_all_repo_sites.py">list all links</a></p>
<h2>w11</h2>
<p>單機場景加上計分<br/><a href="https://mdecd2023.github.io/2b2-pj2bg14">pj2bg14</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg14">repo</a>) 60</p>
<p>修改標題, 加入學員 github 帳號, 以及 w11 下的學員網頁      </p>
<p><a href="https://mdecd2023.github.io/2b2-pj2bg1">pj2bg1</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg1">repo</a>) X 41023246<br/><a href="https://mdecd2023.github.io/2b2-pj2bg2">pj2bg2</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg2">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg3">pj2bg3</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg3">repo</a>) 41023252, 41023211<br/><a href="https://mdecd2023.github.io/2b2-pj2bg4">pj2bg4</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg4">repo</a>) X 41023201<br/><a href="https://mdecd2023.github.io/2b2-pj2bg5">pj2bg5</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg5">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg6">pj2bg6</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg6">repo</a>) 41023226, 41023220 網頁標題未改, 41023233<br/><a href="https://mdecd2023.github.io/2b2-pj2bg7">pj2bg7</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg7">repo</a>) 41023228 網頁標題未改 41023219, 41023221<br/><a href="https://mdecd2023.github.io/2b2-pj2bg8">pj2bg8</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg8">repo</a>) X 41023242<br/><a href="https://mdecd2023.github.io/2b2-pj2bg9">pj2bg9</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg9">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg10">pj2bg10</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg10">repo</a>) 41023241 無學員 github 帳號<br/><a href="https://mdecd2023.github.io/2b2-pj2bg11">pj2bg11</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg11">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg12">pj2bg12</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg12">repo</a>) 41023251, 41023234 網頁標題未改<br/><a href="https://mdecd2023.github.io/2b2-pj2bg13">pj2bg13</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg13">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg14">pj2bg14</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg14">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg15">pj2bg15</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg15">repo</a>) X<br/><a href="https://mdecd2023.github.io/2b2-pj2bg16">pj2bg16</a> (<a href="https://github.com/mdecd2023/2b2-pj2bg16">repo</a>) X</p><h2>wss</h2>
<p><a href="https://blog.heidt.biz/blog/2012/07/19/ssl-websocket-proxy-with-stunnel-howto/">https://blog.heidt.biz/blog/2012/07/19/ssl-websocket-proxy-with-stunnel-howto/</a></p>
<p><a href="https://stackoverflow.com/questions/15403905/warping-ratchet-with-stunnel">https://stackoverflow.com/questions/15403905/warping-ratchet-with-stunnel</a></p>
<p><a href="https://stackoverflow.com/questions/25849193/php-websocket-redirect-with-stunnel">https://stackoverflow.com/questions/25849193/php-websocket-redirect-with-stunnel</a></p>
<p>simAddOnVisualization stream.lua</p>
<p>\3rdparty\coppelia-ws-remote-api\RemoteAPIClient.js</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">; Certificate/key is needed in server mode and optional in client mode
cert = /path/to/&lt;myCert&gt;.pem
key = /path/to/&lt;myKey&gt;.key

; Protocol version (all, SSLv2, SSLv3, TLSv1)
sslVersion = all

; Some security enhancements for UNIX systems - comment them out on Win32
chroot = /var/run/stunnel/

; PID is created inside the chroot jail
pid = /stunnel.pid

; Some performance tunings
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
;compression = zlib

; Some debugging stuff useful for troubleshooting
debug = 7
output = /var/log/stunnel/stunnel.log
;foreground = yes

; Use it for client mode
;client = yes                     !! turn to server mode

; Service-level configuration
[wsServer]
accept = 0.0.0.0:9030             !! listen to all addresses
connect = 127.0.0.1:9090</pre>
<p></p>
<h2>Visualization</h2>
<p>simExtWS 要先執行.</p>
<p>SimAddonVisualization stream.lua 按下下拉式功能表之後顯示 running</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_info()
    autoStart=sim.getNamedBoolParam('visualizationStream.autoStart')
    if autoStart==nil then autoStart=false end
    return {autoStart=autoStart,menu='Connectivity\nVisualization stream'}
end

function sysCall_init()
    resourcesDir=sim.getStringParameter(sim.stringparam_resourcesdir)

    if not simWS then
        sim.addLog(sim.verbosity_errors,'the WS plugin is not available')
        return {cmd='cleanup'}
    end

    wsPort=sim.getNamedInt32Param('visualizationStream.ws.port') or 23020
    sim.addLog(sim.verbosity_scriptinfos,'WS endpoint on port '..tostring(wsPort)..'...')
    if sim.getNamedBoolParam('visualizationStream.ws.retryOnStartFailure') then
        while true do
            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)
            if r then break end
            sim.addLog(sim.verbosity_scriptwarnings,'WS failed to start ('..e..'). Retrying...')
            sim.wait(0.5,false)
        end
    else
        wsServer=simWS.start(wsPort)
    end
    simWS.setOpenHandler(wsServer,'onWSOpen')
    simWS.setCloseHandler(wsServer,'onWSClose')
    simWS.setMessageHandler(wsServer,'onWSMessage')
    simWS.setHTTPHandler(wsServer,'onWSHTTP')
    wsClients={}

    cbor=require('org.conman.cbor')
    base64=require('base64')
    url=require('socket.url')

    sim.test('sim.mergeEvents',true)
    sim.test('sim.cborEvents',true)

    sim.addLog(sim.verbosity_scriptinfos,'e.g. in your local web browser, type: http://127.0.0.1:'..tostring(wsPort))
end

function sysCall_addOnScriptSuspend()
    return {cmd='cleanup'}
end

function sysCall_event(data)
    sendEventRaw(data)
end

function sysCall_cleanup()
    if wsServer then
        simWS.stop(wsServer)
    end
end

function getFileContents(path)
    local f,err,errno=io.open(path,"rb")
    if f then
        local content=f:read("*all")
        f:close()
        return 200,content
    else
        return 404,nil
    end
end

function onWSOpen(server,connection)
    if server==wsServer then
        wsClients[connection]=1
        sendEventRaw(sim.getGenesisEvents(),connection)
    end
end

function onWSClose(server,connection)
    if server==wsServer then
        wsClients[connection]=nil
    end
end

function onWSMessage(server,connection,message)
end

function onWSHTTP(server,connection,resource,data)
    resource=url.unescape(resource)
    local mainPage='threejsFrontend'
    local status,data=404,nil
    if resource=='/' or resource=='/'..mainPage..'.html' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.html')
        if status==200 then
            data=string.gsub(data,'const wsPort = 23020;','const wsPort = '..wsPort..';')
        end
    elseif resource=='/'..mainPage..'.js' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.js')
    elseif resource:sub(1,10)=='/3rdparty/' then
        status,data=getFileContents(resourcesDir..resource)
    end
    if status==404 and resource~='/favicon.ico' then
        sim.addLog(sim.verbosity_errors,'resource not found: '..resource)
    end
    return status,data
end

function sendEventRaw(d,conn)
    if d==nil then return end

    if wsServer then
        for connection,_ in pairs(wsClients) do
            if conn==nil or conn==connection then
                simWS.send(wsServer,connection,d,simWS.opcode.binary)
            end
        end
    end
end

function verbose()
    return sim.getNamedInt32Param('visualizationStream.verbose') or 0
end
</pre>
<h2>WebSocket2</h2>
<p><a href="https://zh.wikipedia.org/zh-tw/WebSocket">WebSocket - 維基百科，自由的百科全書 (wikipedia.org)</a> </p>
<p><a href="https://www.rfc-editor.org/rfc/rfc6455">RFC 6455: The WebSocket Protocol (rfc-editor.org)</a> </p>
<p><a href="https://www.brython.info/static_doc/en/browser.websocket.html">https://www.brython.info/static_doc/en/browser.websocket.html</a> </p>
<p><a href="https://jimmy-huang.medium.com/python%E4%B9%8Bwebsocket%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AF%A6%E4%BD%9C-8ec2474badaa">Python之Websocket介紹與實作</a></p>
<p><a href="https://claire-chang.com/2020/02/26/html5-websocket%E8%88%87socket-io/">WebSocket與Ajax的不同</a></p>
<p>Use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol<br/> provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.</p>
<p>建立跨網際的虛實整合系統需要雙向傳遞即時資訊時使用.</p>
<h2>Leo Editor</h2>
<p><a href="http://tompassin.net/leo/guide/docs/using-leo.html">Leo New User's Guide documentation</a></p>
<h2>Git</h2>
<p>測試在 acp 中加入 public_html 目錄中倉儲的 git pull 指令執行</p>
<p>fatal:  Could not resolve host: github.com</p>
<p>發生原因: 目前的網路設定無法與 github.com 網站連線</p>
<p>解決方法:</p>
<p style="padding-left: 30px;">若使用 https 連線, 請檢查 home_ipv6 目錄下的 .gitconfig, 可能沒有設定 http.proxy</p>
<p style="padding-left: 30px;">若使用 SSH 連線, 請檢查 Putty 設定的 session 中 Proxy, 可能沒有設定 http 對應的代理主機</p>
<h4>cmsimde</h4>
<p>準備利用 <a href="https://stackoverflow.com/questions/23945494/use-html5-to-resize-an-image-before-upload">https://stackoverflow.com/questions/23945494/use-html5-to-resize-an-image-before-upload</a> 中所提供的方法在 5j-5jgx 倉儲中的 cmsimde 進行修改, 以便 resize image before uploading.</p>
<p>To resize an image before uploading it using the jQuery AXuploader, you can use the following steps:</p>
<ol>
<li>Load the image using the FileReader API.</li>
<li>Create an Image object and set its src property to the result of the FileReader API.</li>
<li>for the onload event of the Image object to fire, indicating that the image has been fully loaded.</li>
<li>Create a canvas element and set its dimensions to the desired size of the resized image.</li>
<li>Draw the image onto the canvas using the drawImage method, passing in the Image object as the source and the canvas as the destination.</li>
<li>Convert the canvas to a data URI using the toDataURL method.</li>
<li>Convert the data URI to a Blob using the dataURItoBlob function.</li>
</ol>
<p>Here's an example implementation of the above steps:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">// define the maximum dimensions of the resized image
const MAX_WIDTH = 800;
const MAX_HEIGHT = 800;

// define the dataURItoBlob function
function dataURItoBlob(dataURI) {
  const byteString = atob(dataURI.split(',')[1]);
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i &lt; byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeString });
}

// handle the file upload
$('#file-input').on('change', function() {
  const file = this.files[0];
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = function() {
    const img = new Image();
    img.onload = function() {
      let width = img.width;
      let height = img.height;

      // calculate the new dimensions of the resized image
      if (width &gt; height) {
        if (width &gt; MAX_WIDTH) {
          height *= MAX_WIDTH / width;
          width = MAX_WIDTH;
        }
      } else {
        if (height &gt; MAX_HEIGHT) {
          width *= MAX_HEIGHT / height;
          height = MAX_HEIGHT;
        }
      }

      // create a canvas and draw the resized image onto it
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      // convert the canvas to a data URI and then to a Blob
      const dataURL = canvas.toDataURL(file.type);
      const blob = dataURItoBlob(dataURL);

      // upload the resized image using the AXuploader
      $.axuploader({
        url: 'upload.php',
        data: {
          file: blob
        },
        success: function(response) {
          console.log('Upload successful:', response);
        },
        error: function(xhr) {
          console.error('Upload failed:', xhr.responseText);
        }
      });
    };
    img.src = reader.result;
  };
});
</pre>
<p>In the above code, the MAX_WIDTH and MAX_HEIGHT constants define the maximum dimensions of the resized image. The dataURItoBlob function is a utility function that converts a data URI to a Blob. The change event of the file input element is handled to perform the image resizing and upload using the AXuploader.</p>
<p>If server side is Flask based:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, request
import base64
import uuid
import os

app = Flask(__name__)

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' in request.files:
        file = request.files['file']
        # process the uploaded file
        if file:
            # decode the base64 data
            data = base64.b64decode(request.form['file_data'])

            # save the data to a file
            filename = str(uuid.uuid4()) + '.' + file.filename.split('.')[-1]
            with open(os.path.join('uploads', filename), 'wb') as f:
                f.write(data)

            return 'Upload successful'
    return 'Upload failed'
</pre>
<p>In the above code, the Flask server defines a route /upload that receives a POST request containing the uploaded file data as a base64-encoded string in the request body. The code decodes the base64 data, generates a unique filename, and saves the data to a file in the uploads directory. The filename is returned as a response to indicate the successful upload.</p>
<p>To make a request to this Flask endpoint from the client-side using jQuery AXuploader, you can modify the data option in the $.axuploader method to include the base64-encoded data:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">$.axuploader({
    url: '/upload',
    data: {
        file_data: canvas.toDataURL(file.type).split(',')[1] // pass the base64-encoded data
    },
    success: function(response) {
        console.log('Upload successful:', response);
    },
    error: function(xhr) {
        console.error('Upload failed:', xhr.responseText);
    }
});
</pre>
<p>In the above code, the file_data field is added to the data option of the $.axuploader method and its value is set to the base64-encoded data URI of the resized image. This data is sent to the Flask server as the request body of the POST request. The Flask server can then decode this data and save it to a file as shown in the previous code snippet.</p>
<p>If file is uploaded chunk by chunk:</p>
<p>Python</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, request
import base64
import uuid
import os

app = Flask(__name__)

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' in request.files:
        file = request.files['file']
        # process the uploaded file
        if file:
            # initialize the data buffer
            data = b''
            # read the chunks and append to the buffer
            while True:
                chunk = file.read(1024 * 1024) # read 1MB chunk
                if not chunk:
                    break
                data += chunk

            # decode the base64 data
            data = base64.b64decode(request.form['file_data'])

            # save the data to a file
            filename = str(uuid.uuid4()) + '.' + file.filename.split('.')[-1]
            with open(os.path.join('uploads', filename), 'wb') as f:
                f.write(data)

            return 'Upload successful'
    return 'Upload failed'
</pre>
<p>Javascript:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">$.axuploader({
    url: '/upload',
    data: {
        file_data: canvas.toDataURL(file.type).split(',')[1] // pass the base64-encoded data
    },
    chunkSize: 1024 * 1024, // upload in 1MB chunks
    success: function(response) {
        console.log('Upload successful:', response);
    },
    error: function(xhr) {
        console.error('Upload failed:', xhr.responseText);
    }
});
</pre>
<h1>zmqRemoteApi</h1>
<script src="https://cdn.jsdelivr.net/npm/zmq@2.15.3/index.min.js"></script>
<script>
const zmq = require('zeromq');

// Set up the ZMQ socket connection
const socket = zmq.socket('req');
const port = 23000; // Port number used by the ZMQ Remote API server
const ipAddress = '[2001:288:6004:17:10ff::5]'; // IP address of the machine running the ZMQ Remote API server
const connectionAddress = `tcp://${ipAddress}:${port}`;
socket.connect(connectionAddress);

// Function to send a request to the ZMQ Remote API server
function sendRequest(request) {
  return new Promise((resolve, reject) => {
    socket.send(JSON.stringify(request));
    socket.on('message', (response) => {
      resolve(JSON.parse(response.toString()));
    });
  });
}

// Get the object handle from the ZMQ Remote API server
async function getObject(objectName) {
  const request = {
    cmd: 'sim.getObject',
    objectName: objectName
  };

  const response = await sendRequest(request);
  return response.handle;
}

// Set the initial position of the cube
const initialPosition = [0, 0, 0];
const cubeHandle = await getObject('/cube');
await sendRequest({
  cmd: 'sim.setObjectPosition',
  handle: cubeHandle,
  relativeToObjectHandle: -1,
  position: initialPosition
});

// Set the increment value for each movement
const increment = 0.1;

// Listen for keydown events
document.addEventListener('keydown', async (event) => {
  const key = event.key;

  // Move the cube based on the arrow keys
  switch (key) {
    case 'ArrowUp':
      await moveCube([0, increment, 0]);
      break;
    case 'ArrowDown':
      await moveCube([0, -increment, 0]);
      break;
    case 'ArrowLeft':
      await moveCube([-increment, 0, 0]);
      break;
    case 'ArrowRight':
      await moveCube([increment, 0, 0]);
      break;
  }
});

// Function to move the cube by a given translation vector
async function moveCube(translation) {
  const currentPosition = await sendRequest({
    cmd: 'sim.getObjectPosition',
    handle: cubeHandle,
    relativeToObjectHandle: -1
  });

  const newPosition = currentPosition.position.map((coord, index) => coord + translation[index]);

  await sendRequest({
    cmd: 'sim.setObjectPosition',
    handle: cubeHandle,
    relativeToObjectHandle: -1,
    position: newPosition
  });
}
</script><h1>Coppeliasim</h1>
<p><a href="https://forum.coppeliarobotics.com/viewtopic.php?t=390">https://forum.coppeliarobotics.com/viewtopic.php?t=390</a> </p>
<p>Actually, this is how it is done:</p>
<ul>
<li>The wheel is composed by 2 spheres and 2 revolute joints in following configuration: robotBody - activeJoint - nonRespondableSphere - passiveJoint - respondableSphere</li>
<li>The 2 joints have to be at their specific angle (perpendicular in your case)</li>
<li>There must be a non-threaded <a class="postlink" href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">child script</a> attached to one of those objects, preferably the first joint. It is in charge of resetting the respondableSphere and reorienting the passiveJoints, and this in each simulation loop</li>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from zmqRemoteApi_IPv6 import RemoteAPIClient
import time
import math
import keyboard

# Connect to the CoppeliaSim scene server
client = RemoteAPIClient('localhost', 23000)
sim = client.getObject('sim')
#sim.startSimulation()

# Load the Omniwheel 45deg A1 model
wheel_a1_file = "C:/CoppeliaSimEdu_4.5.1_rev4_for_cd2023/models/components/locomotion and propulsion/Omniwheel 45deg A.ttm"
wheel_a1_handle = sim.loadModel(wheel_a1_file)
wheel_a1_name = "wheelA1"
sim.setObjectAlias(wheel_a1_handle, wheel_a1_name)

# Load the Omniwheel 45deg A2 model
wheel_a2_file = "C:/CoppeliaSimEdu_4.5.1_rev4_for_cd2023/models/components/locomotion and propulsion/Omniwheel 45deg A.ttm"
wheel_a2_handle = sim.loadModel(wheel_a2_file)
wheel_a2_name = "wheelA2"
sim.setObjectAlias(wheel_a2_handle, wheel_a2_name)

# Load the Omniwheel 45deg B1 model
wheel_b1_file = "C:/CoppeliaSimEdu_4.5.1_rev4_for_cd2023/models/components/locomotion and propulsion/Omniwheel 45deg B.ttm"
wheel_b1_handle = sim.loadModel(wheel_b1_file)
wheel_b1_name = "wheelB1"
sim.setObjectAlias(wheel_b1_handle, wheel_b1_name)

# Load the Omniwheel 45deg B2 model
wheel_b2_file = "C:/CoppeliaSimEdu_4.5.1_rev4_for_cd2023/models/components/locomotion and propulsion/Omniwheel 45deg B.ttm"
wheel_b2_handle = sim.loadModel(wheel_b2_file)
wheel_b2_name = "wheelB2"
sim.setObjectAlias(wheel_b2_handle, wheel_b2_name)

# Create a chassis object
chassis_handle = sim.createPureShape(0, 8, [0.1, 0.15, 0.05], 1, None)
sim.setObjectAlias(chassis_handle, 'chassis')

# Set the position and orientation of the chassis
sim.setObjectPosition(chassis_handle, -1, [0, 0, 0.05])
sim.setObjectOrientation(chassis_handle, -1, [0, 0, 0])

# Set the positions of the wheels relative to the chassis
wheel_a1_pos = [-0.085, 0.075, -0.005]
wheel_a2_pos = [0.085, -0.075, -0.005]
wheel_b1_pos = [0.085, 0.075, -0.005]
wheel_b2_pos = [-0.085, -0.075, -0.005]

# Set the positions of the wheels
sim.setObjectPosition(wheel_a1_handle, chassis_handle, wheel_a1_pos)
sim.setObjectPosition(wheel_a2_handle, chassis_handle, wheel_a2_pos)
sim.setObjectPosition(wheel_b1_handle, chassis_handle, wheel_b1_pos)
sim.setObjectPosition(wheel_b2_handle, chassis_handle, wheel_b2_pos)

# Set the parent-child relationship between the wheels and the chassis
sim.setObjectParent(wheel_a1_handle, chassis_handle, True)
sim.setObjectParent(wheel_a2_handle, chassis_handle, True)
sim.setObjectParent(wheel_b1_handle, chassis_handle, True)
sim.setObjectParent(wheel_b2_handle, chassis_handle, True)

# Set wheel velocities
wheel_a1_velocity = 0
wheel_a2_velocity = 0
wheel_b1_velocity = 0
wheel_b2_velocity = 0

# Set the control loop
while True:
    if keyboard.is_pressed('up'):
        wheel_a1_velocity = 10
        wheel_a2_velocity = 10
        wheel_b1_velocity = 10
        wheel_b2_velocity = 10
    elif keyboard.is_pressed('down'):
        wheel_a1_velocity = -10
        wheel_a2_velocity = -10
        wheel_b1_velocity = -10
        wheel_b2_velocity = -10
    elif keyboard.is_pressed('left'):
        wheel_a1_velocity = -10
        wheel_a2_velocity = 10
        wheel_b1_velocity = 10
        wheel_b2_velocity = -10
    elif keyboard.is_pressed('right'):
        wheel_a1_velocity = 10
        wheel_a2_velocity = -10
        wheel_b1_velocity = -10
        wheel_b2_velocity = 10
    else:
        wheel_a1_velocity = 0
        wheel_a2_velocity = 0
        wheel_b1_velocity = 0
        wheel_b2_velocity = 0

    # Set the target velocities for the wheels
    sim.setJointTargetVelocity(wheel_a1_handle, wheel_a1_velocity)
    sim.setJointTargetVelocity(wheel_a2_handle, wheel_a2_velocity)
    sim.setJointTargetVelocity(wheel_b1_handle, wheel_b1_velocity)
    sim.setJointTargetVelocity(wheel_b2_handle, wheel_b2_velocity)

    # Let CoppeliaSim process the wheel velocities
    time.sleep(0.01)

    if keyboard.is_pressed('q'):
        # Press 'q' to break the loop
        break

# Stop the simulation
# sim.stopSimulation()
</pre>
<p>當使用按下 Modules -&gt; Connectivity -&gt;Visualization stream 時, 系統呼叫位於 CoppeliaSim 套件根目錄中的 simAddOnVisualization stream.lua 檔案執行. 其中的 http server 是由 .lua 程式中的 function onWSHTTP(server,connection,resource,data) </p>
<p><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EWdB5MhlZRJKjt5UiNRebR8BN6_AmU0IX1HC7Y6dnRBzQw?e=dLPcDi">Download CoppeliasimEdu_4.3.0rev12.7z</a> (for @nfu users only)</p>
<p><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EQfam1spz4JHqczkc1uN4H0BJu2jvs07GlPmhUHyMOTuXA?e=cnZSjM">Download CoppeliaSimEdu_4.5.1rev4.7z</a> (for@nfu users only)</p>
<p>因為 4.5.1 將 usrset.txt 存至 AppData  目錄下, 因此若設為可攜則必須從 C:\users\%USERNAME% 目錄中的 AppData\Roaming\CoppeliaSim 目錄取用相關設定, 因此首次設定完成後, 必須將 C:\ 中的設定存至隨身碟, 且每次啟動可攜時, 再將此設定目錄從可攜檔案中, 以 xcopy 複製到 C:\ 對應目錄.</p>
<p>必須加入 start_ipv6.bat 中的目錄複製指令:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">Xcopy %Disk%:\home_ipv6\AppData\Roaming\Coppeliasim C:\users\%USERNAME%\AppData\Roaming\Coppeliasim /E /H /C /I /Y</pre>
<p><span style="background-color: #ccffcc;">這裡還需確認 4.5.1 版的 CoppeliaSim 設定檔案儲存位置為: </span></p>
<p>C:\Users\pj2023\Documents\Roaming\CoppeliaSim</p>
<p>抑或:</p>
<p>C:\Users\pj2023\AppData\Roaming\CoppeliaSim</p>
<hr/>
<p>希望能在 https 與 wss 協定下啟動 Visualization Stream 功能</p>
<p>由於 Coppeliasim 4.5.1 會將 usrset.txt 存入 AppData, 且只能使用 C:\users 對應的帳號下 AppData, 因此使用隨身碟中的系統, 必須動用 xcopy 將存於隨身碟的相關設定寫入 C:\ 對應區域, 才可使用滑鼠點擊開啟 CoppeliaSim, 但若以 Command 啟動 CoppeliaSim, 則部分的 plugin 無法存取, 例如: code editor plugin.</p>
<p>Under simExtWS.dll</p>
<p>Websocket server in lua:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function onMessage(server,connection,data)
    print('received:',data)
    data='Hello there'
    print('sending:',data)
    simWS.send(server,connection,data)
end

function sysCall_init()
    server=simWS.start(9000)
    simWS.setMessageHandler(server,'onMessage')
end</pre>
<p>echo client in python</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import asyncio
import websockets

async def hello():
    async with websockets.connect("ws://localhost:9000") as websocket:
        payload = 'Hello, world!'
        print('Sending:', payload)
        await websocket.send(payload)
        payload = await websocket.recv()
        print('Received:', payload)

asyncio.run(hello())
</pre>
<p>broadcasting server in lua:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function onOpen(server,connection)
    clients[server]=clients[server] or {}
    clients[server][connection]=1
end

function onClose(server,connection)
    clients[server][connection]=nil
end

function broadcast(data)
    for server,connections in pairs(clients) do
        for connection,_ in pairs(connections) do
            simWS.send(server,connection,data)
        end
    end
end

function sysCall_init()
    clients={}
    server=simWS.start(9000)
    simWS.setOpenHandler(server,'onOpen')
    simWS.setCloseHandler(server,'onClose')
end

function sysCall_sensing()
    local t=sim.getSimulationTime()
    if lastBroadcastTime and (t-lastBroadcastTime)&lt;1 then return end
    lastBroadcastTime=t
    i=(i or 0)+1
    broadcast('#'..i)
end</pre>
<p>broadcasting client in python:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import asyncio
import websockets

async def main():
    async with websockets.connect("ws://localhost:9000") as websocket:
        while True:
            payload = await websocket.recv()
            print('Received:', payload)

asyncio.run(main())
</pre>
<p>http get server in lua:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function onHTTP(server,connection,resource,data)
    if resource=='/' then
        local ua=sim.getStringNamedParam('simWS.userAgent')
        return 200,'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Index&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;'..ua..'&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'
    end
end

function sysCall_init()
    clients={}
    server=simWS.start(9000)
    simWS.setHTTPHandler(server,'onHTTP')
end
</pre>
<p>Use browser <a href="http://localhost:9000">http://localhost:9000</a></p>
<hr/>
<p>simAddOnVisualization stream.lua</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_info()
    autoStart=sim.getNamedBoolParam('visualizationStream.autoStart')
    if autoStart==nil then autoStart=false end
    return {autoStart=autoStart,menu='Connectivity\nVisualization stream'}
end

function sysCall_init()
    resourcesDir=sim.getStringParameter(sim.stringparam_resourcesdir)

    if not simWS then
        sim.addLog(sim.verbosity_errors,'the WS plugin is not available')
        return {cmd='cleanup'}
    end

    wsPort=sim.getNamedInt32Param('visualizationStream.ws.port') or 23020
    sim.addLog(sim.verbosity_scriptinfos,'WS endpoint on port '..tostring(wsPort)..'...')
    if sim.getNamedBoolParam('visualizationStream.ws.retryOnStartFailure') then
        while true do
            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)
            if r then break end
            sim.addLog(sim.verbosity_scriptwarnings,'WS failed to start ('..e..'). Retrying...')
            sim.wait(0.5,false)
        end
    else
        wsServer=simWS.start(wsPort)
    end
    simWS.setOpenHandler(wsServer,'onWSOpen')
    simWS.setCloseHandler(wsServer,'onWSClose')
    simWS.setMessageHandler(wsServer,'onWSMessage')
    simWS.setHTTPHandler(wsServer,'onWSHTTP')
    wsClients={}

    cbor=require('org.conman.cbor')
    base64=require('base64')
    url=require('socket.url')

    sim.test('sim.mergeEvents',true)
    sim.test('sim.cborEvents',true)

    sim.addLog(sim.verbosity_scriptinfos,'e.g. in your local web browser, type: http://127.0.0.1:'..tostring(wsPort))
end

function sysCall_addOnScriptSuspend()
    return {cmd='cleanup'}
end

function sysCall_event(data)
    sendEventRaw(data)
end

function sysCall_cleanup()
    if wsServer then
        simWS.stop(wsServer)
    end
end

function getFileContents(path)
    local f,err,errno=io.open(path,"rb")
    if f then
        local content=f:read("*all")
        f:close()
        return 200,content
    else
        return 404,nil
    end
end

function onWSOpen(server,connection)
    if server==wsServer then
        wsClients[connection]=1
        sendEventRaw(sim.getGenesisEvents(),connection)
    end
end

function onWSClose(server,connection)
    if server==wsServer then
        wsClients[connection]=nil
    end
end

function onWSMessage(server,connection,message)
end

function onWSHTTP(server,connection,resource,data)
    resource=url.unescape(resource)
    local mainPage='threejsFrontend'
    local status,data=404,nil
    if resource=='/' or resource=='/'..mainPage..'.html' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.html')
        if status==200 then
            data=string.gsub(data,'const wsPort = 23020;','const wsPort = '..wsPort..';')
        end
    elseif resource=='/'..mainPage..'.js' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.js')
    elseif resource:sub(1,10)=='/3rdparty/' then
        status,data=getFileContents(resourcesDir..resource)
    end
    if status==404 and resource~='/favicon.ico' then
        sim.addLog(sim.verbosity_errors,'resource not found: '..resource)
    end
    return status,data
end

function sendEventRaw(d,conn)
    if d==nil then return end

    if wsServer then
        for connection,_ in pairs(wsClients) do
            if conn==nil or conn==connection then
                simWS.send(wsServer,connection,d,simWS.opcode.binary)
            end
        end
    end
end

function verbose()
    return sim.getNamedInt32Param('visualizationStream.verbose') or 0
end
</pre>
<p>threejsFrontend.js</p>
<p>simAddonVisualization stream.lua modified: not work yet</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_info()
    autoStart=sim.getNamedBoolParam('visualizationStream.autoStart')
    if autoStart==nil then autoStart=false end
	return {autoStart=autoStart,menu='Connectivity\nVisualization stream (HTTPS)'}
end

function sysCall_init()
    addOnPath=sim.getStringParam(sim.stringparam_addonpath)
    addOnBaseName=addOnPath:match("^.+/(.+).lua$")
    addOnDir=addOnPath:match("^(.+)/.*")

	if not simWS then
        sim.addLog(sim.verbosity_errors,'the WS plugin is not available')
        return {cmd='cleanup'}
    end

    wsPort = 443
	
	certFile = "C:/CoppeliaSimEdu_4.3.0_rev12/localhost.crt"
	keyFile = "C:/CoppeliaSimEdu_4.3.0_rev12/localhost.key"
	
	cert = assert(io.open(certFile, "r"))
	key = assert(io.open(keyFile, "r"))
	ssl_params = {cert = cert:read("*all"), key = key:read("*all")}
	cert:close()
	key:close()

    sim.addLog(sim.verbosity_scriptinfos,'WS endpoint on port '..tostring(wsPort)..'...')

    wssServer = simWS.start(wsPort)
	
	simWS.setOpenHandler(wssServer, 'onWSOpen')
	simWS.setCloseHandler(wssServer, 'onWSClose')
	simWS.setMessageHandler(wssServer, 'onWSMessage')
	simWS.setHTTPHandler(wssServer, 'onWSHTTP')
	wsClients = {}

    cbor=require('org.conman.cbor')
    base64=require('base64')
    url=require('socket.url')

    sim.test('sim.mergeEvents',true)
    sim.test('sim.cborEvents',true)

    sim.addLog(sim.verbosity_scriptinfos,'e.g. in your local web browser, type: https://127.0.0.1:'..tostring(wsPort))
end

function sysCall_addOnScriptSuspend()
    return {cmd='cleanup'}
end

function sysCall_event(data)
    sendEventRaw(data)
end

function sysCall_cleanup()
    if wsServer then
        simWS.stop(wsServer)
    end
end

function getFileContents(path)
    local f,err,errno=io.open(path,"rb")
    if f then
        local content=f:read("*all")
        f:close()
        return 200,content
    else
        return 404,nil
    end
end

function onWSOpen(server,connection)
    if server==wsServer then
        wsClients[connection]=1
        sendEventRaw(sim.getGenesisEvents(),connection)
    end
end

function onWSClose(server,connection)
    if server==wsServer then
        wsClients[connection]=nil
    end
end

function onWSMessage(server,connection,message)
end

function onWSHTTP(server,connection,resource,data)
    resource=url.unescape(resource)
    local mainPage='threejsFrontend'
    local status,data=404,nil
    if resource=='/' or resource=='/'..mainPage..'.html' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.html')
        if status==200 then
            data=string.gsub(data,'const wsPort = 23020;','const wsPort = '..wsPort..';')
        end
    elseif resource=='/'..mainPage..'.js' then
        status,data=getFileContents(resourcesDir..'/'..mainPage..'.js')
    elseif resource:sub(1,10)=='/3rdparty/' then
        status,data=getFileContents(resourcesDir..resource)
    end
    if status==404 and resource~='/favicon.ico' then
        sim.addLog(sim.verbosity_errors,'resource not found: '..resource)
    end
    return status,data
end

function sendEventRaw(d,conn)
    if d==nil then return end

    if wsServer then
        for connection,_ in pairs(wsClients) do
            if conn==nil or conn==connection then
                simWS.send(wsServer,connection,d,simWS.opcode.binary)
            end
        end
    end
end

function verbose()
    return sim.getNamedInt32Param('visualizationStream.verbose') or 0
end
</pre><h2>WebSocket</h2>
<p>希望能讓 CoppeliaSim 的 Visualization stream 在 https 運作</p>
<p>使用 Stunnel 可以將 23020 轉向 443, 只要提供 self-signed certification 就可以.</p>
<p>但是其中的雙向資料是透過 ws:// websocket protocol 進行傳送, 因此必須處理為 wss:// 才可以與 https 結合運作.</p>
<hr/>
<p>有關 Websocket protocol 運作原理:</p>
<p>WebSocket是一種在<span style="background-color: #ffff00;">Web瀏覽器和網頁伺服器之間提供全雙工通訊通道的協議</span>。WebSocket協議允許網頁使用一個單一的TCP連接來進行全雙工通訊，以取代傳統的HTTP請求/響應模型，可以更快地傳輸數據，減少延遲。</p>
<p>WebSocket的運作原理如下：</p>
<p>1. 首先，客戶端發起一個WebSocket請求，這個請求類似於HTTP請求，但是使用的是特殊的WebSocket URL格式，例如：ws://example.com/chat。(因此目前的重點是讓<span style="background-color: #ffff00;">客戶端發出的 WebSocket 採 https 傳送</span>)</p>
<p>2. 伺服器接收到請求後，會回應一個HTTP 101切換協議的狀態碼，表示伺服器同意切換到WebSocket協議。(<span style="background-color: #ffff00;">要確定 SimAddonVisualization stream.lua 就是網頁伺服器, 而瀏覽器端的 client 則是 threejsFrontend.js</span>)</p>
<p>3. 接下來，客戶端和伺服器之間的通訊通道就建立了。雙方可以開始互相發送消息，並且可以隨時中斷連接。</p>
<p>4. WebSocket協議通訊過程中，雙方可以直接傳送二進位數據，而不需要像HTTP一樣需要轉換成文本格式。</p>
<p>5. 最後，當一方決定關閉WebSocket連接時，會向對方發送一個關閉封包。對方接收到關閉封包後，會回應一個關閉確認封包，然後關閉連接。</p>
<p>總體來說，WebSocket協議的運作原理就是通過建立一個全雙工通訊通道，實現網頁與伺服器之間的實時數據通訊。</p>
<p>在 CoppeliaSim 4.3.0 版本中，CoppeliaSim 提供了視覺化串流（Visualization stream）功能，它可以將 CoppeliaSim 中的 3D 串流資料傳輸到外部應用程式中，例如網頁瀏覽器。其中，"SimAddonVisualization stream.lua" 就是 CoppeliaSim 中的 Web 伺服器，負責將串流資料推送到網路中，而 threejsFrontend.js 則是網頁瀏覽器端的客戶端程式，負責接收來自 CoppeliaSim的串流資料，解讀並建立 3D 場景。</p>
<p>simExtWS.dll 庫負責建立 WebSocket 伺服器，並將 3D 場景串流資料推送到 WebSocket 客戶端，而simAddOnVisualizationStream.lua 程式則負責控制 WebSocket 服務器的啟動、停止和傳輸串流資料的內容。threejsFrontend.js 則是網頁瀏覽器端的客戶端程式，負責接收來自 CoppeliaSim 的串流資料，解讀場景中的元件後<span>，</span>利用 three.js 建立出瀏覽器中的 3D 場景。</p>
<p>為了讓 simAddonViaualization stream.lua 能在 SSL 模式下運作, 需要</p>
<p>lua 5.3.5 版解譯器適用的 luasec 或 luassl:</p>
<p><a href="https://github.com/brunoos/luasec">https://github.com/brunoos/luasec</a> </p>
<p><a href="https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Windows">https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Windows</a> </p>
<p><a href="https://luabinaries.sourceforge.net/download.html">https://luabinaries.sourceforge.net/download.html</a> </p>
<h3>瀏覽器串流</h3>
<p><iframe height="480" src="https://copsim.cycu.org/" width="640"></iframe></p>
<p>以下設定適用於 CoppeliaSim 採 https 檢視瀏覽器上的場景串流.</p>
<p>stunnel.conf 檔案設定:</p>
<p>將 http 原先在 port 23020 的連線指向 https 外部 IP, 意即 server 的 SSL/TLS 在外部 IP 位址的 443 port 中, 而<span style="background-color: #ffff00;">隨後的 WebSocket client 要建立 wss:// 雙向連結時, 必須指向外部 IP address 中的 port 443</span>.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[https]
accept =140.130.17.108:443
connect = 127.0.0.1:23020
cert = c:\tmp\localhost.crt
key = c:\tmp\localhost.key</pre>
<p>threejsFrontend.html 中:</p>
<p><span style="background-color: #ffff00;">因為 client 要以 wss:// 建立雙向連線, 必須指令 https 對應的 port, 也就是 443</span>.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">&lt;script&gt;
    const wsPort = 443;
    const codec = "cbor";
&lt;/script&gt;</pre>
<p>simAddonVisualization stream.lua 中:</p>
<p>Server 內部由 Modules -&gt; Connectivity -&gt; Visualization Stream 時就是執行 <span style="background-color: #ffff00;">simAddonVisualization stream.lua 啟動時以內建的 http port 23020 啟動</span>, 也就是 stunnel 設定中的 connect 伺服器封包來源, 經由 stunnel 後, 則以外部 IP address 從 443 port 讓 wss:// WebSocket 連線提出 requests.</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">    wsPort=sim.getNamedInt32Param('visualizationStream.ws.port') or 23020
    sim.addLog(sim.verbosity_scriptinfos,'WS endpoint on port '..tostring(wsPort)..'...')
    if sim.getNamedBoolParam('visualizationStream.ws.retryOnStartFailure') then
        while true do
            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)
            if r then break end
            sim.addLog(sim.verbosity_scriptwarnings,'WS failed to start ('..e..'). Retrying...')
            sim.wait(0.5,false)
        end
    else
        wsServer=simWS.start(wsPort)
    end</pre>
<p>threejsFrontend.js 中:</p>
<p>這是 <span style="background-color: #ffff00;">client 端擬以 wss:// 提出 requests, 必須將連線指向外部 IP 位址的 port 443</span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">class VisualizationStreamClient {
    constructor(host = '140.130.17.108', port = 443, codec = 'cbor') {
        this.host = host;
        this.port = port;
        this.codec = codec;
        this.websocket = new ReconnectingWebSocket(`wss://${this.host}:${this.port}`);</pre>
<p>同樣在 threejsFrontend.js 中 line 3127:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">// original port is 23050 Yen changed to 443
var remoteApiClient = new RemoteAPIClient(window.location.hostname, 443, 'cbor', {createWebSocket: url =&gt; new ReconnectingWebSocket(url)});
</pre>
<p>RemoteAPIclient.js 中:</p>
<p>這也是 <span style="background-color: #ffff00;">WebSocket client 端, 以 wss:// 提出 requests, 必須將連線指向外部 IP 位址的 port 443</span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">class RemoteAPIClient {
    constructor(host = '140.130.17.108', port = 443, codec = "cbor", opts = {}) {
        this.host = host;
        this.port = port;
        this.codec = codec;
        var packMessage;
        var unpackMessage;
        if(this.codec == 'cbor') {
            //this.websocket.binaryType = "arraybuffer";
            packMessage = data =&gt; CBOR.encode(data);
            unpackMessage = async data =&gt; CBOR.decode(await data.arrayBuffer());
        } else if(this.codec == "json") {
            packMessage = data =&gt; JSON.stringify(data);
            unpackMessage = data =&gt; JSON.parse(data);
        }
        var wsOpts = {
            packMessage,
            unpackMessage,
            // attach requestId to message as `id` field
            attachRequestId: (data, requestId) =&gt; Object.assign({id: requestId}, data),
            // read requestId from message `id` field
            extractRequestId: data =&gt; data &amp;&amp; data.id,
        };
        for(var k in opts)
            wsOpts[k] = opts[k];
        this.websocket = new WebSocketAsPromised(`wss://${this.host}:${this.port}`, wsOpts);
    }</pre>
<p><span style="background-color: #ffff00;">simAddOnWS remote API server.lua 中 lin</span></p>
<p>&gt;:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- original port is 23050 Yen changes to 443
port=sim.getNamedInt32Param('wsRemoteApi.port') or 443</pre>
<p></p>
<h2>counter</h2>
<p><a href="https://www.thingiverse.com/thing:5452444/files">https://www.thingiverse.com/thing:5452444/files</a> </p>
<p><a href="https://woodgears.ca/counter/">https://woodgears.ca/counter/</a></p>
<p><a href="https://youtu.be/lwt8QujQv5s">https://youtu.be/lwt8QujQv5s</a> </p>
<p><a href="https://www.printables.com/model/76018-mechanical-tally-counter-50/files">https://www.printables.com/model/76018-mechanical-tally-counter-50/files</a> </p>
<p><a href="https://youtu.be/fHxMHOnwhCA">https://youtu.be/fHxMHOnwhCA</a> </p>
<p>以下 jpg 檔案取自:</p>
<p style="padding-left: 30px;"><a href="https://www.myminifactory.com/object/3d-print-mechanical-counter-31952">https://www.myminifactory.com/object/3d-print-mechanical-counter-31952</a> </p>
<p><img alt="" height="400" src="/images/counter1.jpg" width="400"/><img alt="" height="400" src="/images/counter2.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/counter3.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/counter4.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/counter5.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/counter6.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/counter7.jpg" width="400"/></p><h2>copsim</h2>
<p>Flutter app and Coppeliasim:</p>
<p style="padding-left: 30px;">Establish communication from the Flutter app: In your Flutter app, you'll need to establish a connection to the ZMQRemoteAPI server using the appropriate ZeroMQ library for Flutter. One popular library is zeromq.dart, which provides ZeroMQ bindings for Dart.</p>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">import 'package:zeromq/zeromq.dart';

void main() async {
  // Connect to the ZMQRemoteAPI server
  final context = ZContext();
  final requester = ZSocket(context, ZSocketType.req);
  await requester.connect('tcp://localhost:23000'); // Adjust the address and port as per your setup

  // Send a command to CoppeliaSim
  final command = 'simxStartSimulation'; // Example command to start the simulation
  final commandBytes = command.codeUnits;
  await requester.send(ZFrame.fromBytes(commandBytes));

  // Receive the response from CoppeliaSim
  final response = await requester.receive();
  final responseBytes = response.first.bytes;
  final responseString = String.fromCharCodes(responseBytes);
  print('Response: $responseString');

  // Cleanup
  await requester.close();
  context.destroy();
}
</pre>
<p>Brython use Javascript ZMQ:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, window

# Use the JS API to access the ZWS library
# https://github.com/zeromq/zwssock
zws = window.ZWS

# Create a ZWS socket and connect to the ZMQRemoteAPI server in CoppeliaSim
socket = zws.createSocket('ws://localhost:23000')  # Adjust the address and port as per your setup
socket.onopen = lambda event: on_socket_open(event)

# Handle socket opening
def on_socket_open(event):
    print("WebSocket connection established")
    
    # Send the ZMQRemoteAPI commands to control the BubbleRob robot
    socket.send("simxStartSimulation")
    socket.send("simxSynchronous(True)")
    socket.send("handle = simxGetObjectHandle('BubbleRob', -1)[1]")
    socket.send("simxSetJointTargetVelocity(handle, 0.5, simx_opmode_oneshot_wait)")
    
    # Move the robot in a circular path
    for _ in range(500):  # Adjust the number of iterations as needed
        socket.send("simxSynchronousTrigger()")
    
    # Stop the simulation
    socket.send("simxStopSimulation")

# Handle socket messages
def on_socket_message(event):
    print("Received message:", event.data)

# Set the message and close handlers
socket.onmessage = on_socket_message
socket.onclose = lambda event: print("WebSocket connection closed")

# Cleanup
def cleanup():
    socket.close()

# Call the cleanup function when the Brython script is terminated
document.bind("beforeunload", cleanup)
</pre>
<p>Lead BubbleRob move in circle:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, window

# Use the JS API to access the ZWS library
zws = window.ZWS

# Create a ZWS socket and connect to the ZMQRemoteAPI server in CoppeliaSim
socket = zws.createSocket('ws://localhost:23000')  # Adjust the address and port as per your setup
socket.onopen = lambda event: on_socket_open(event)

# Handle socket opening
def on_socket_open(event):
    print("WebSocket connection established")

    # Send the ZMQRemoteAPI commands to control the BubbleRob robot
    socket.send("simxStartSimulation")
    socket.send("simxSynchronous(True)")
    socket.send("handle = simxGetObjectHandle('BubbleRob', -1)[1]")
    
    # Define the circle radius and target velocity
    radius = 0.5  # Adjust the circle radius as needed
    velocity = 0.5  # Adjust the target velocity as needed

    # Calculate the linear velocity and angular velocity for the circular path
    linear_velocity = velocity
    angular_velocity = linear_velocity / radius
    
    # Calculate the time required to complete the circular path
    circumference = 2 * 3.14159 * radius
    time = circumference / linear_velocity

    # Set the robot's target velocities for linear and angular motion
    socket.send(f"simxSetJointTargetVelocity(handle, {linear_velocity}, simx_opmode_oneshot_wait)")
    socket.send(f"simxSetJointTargetVelocity(handle + 1, {angular_velocity}, simx_opmode_oneshot_wait)")

    # Move the robot in a circular path for the specified time
    socket.send(f"simxPauseCommunication(True)")
    socket.send(f"simxSynchronousTrigger()")
    socket.send(f"simxPauseCommunication(False)")

    for _ in range(int(time * 1000)):  # Adjust the time scale as needed
        socket.send("simxSynchronousTrigger()")

    # Stop the robot's motion
    socket.send(f"simxSetJointTargetVelocity(handle, 0, simx_opmode_oneshot_wait)")
    socket.send(f"simxSetJointTargetVelocity(handle + 1, 0, simx_opmode_oneshot_wait)")

    # Stop the simulation
    socket.send("simxStopSimulation")

# Handle socket messages
def on_socket_message(event):
    print("Received message:", event.data)

# Set the message and close handlers
socket.onmessage = on_socket_message
socket.onclose = lambda event: print("WebSocket connection closed")

# Cleanup
def cleanup():
    socket.close()

# Call the cleanup function when the Brython script is terminated
document.bind("beforeunload", cleanup)
</pre>
<p>If you need to implement some form of access control or authentication between the Brython client and the server-side component (such as the ZMQRemoteAPI server or any other backend service), you can consider using standard web authentication mechanisms.</p>
<p>Here's a high-level overview of how you can approach implementing access control:</p>
<p>Implement a server-side authentication mechanism: On the server side, you can create an authentication system that handles user registration, login, and session management. This can be implemented using a web framework or custom server-side code.</p>
<p>Secure the server-side component: Ensure that the server-side component (e.g., ZMQRemoteAPI server or backend service) is only accessible to authenticated and authorized users. You can achieve this by validating user credentials or using access tokens for authentication.</p>
<p>Implement authentication in the Brython client: In the Brython client, you can implement authentication features such as a login form. When the user submits their credentials, the client can send a request to the server-side authentication endpoint to authenticate the user.</p>
<p>Manage user sessions: Once the user is authenticated, you can generate a session token or cookie on the server side and send it back to the Brython client. The client can store this token and include it in subsequent requests to the server to maintain the session.</p>
<p>Include the authentication token in ZMQRemoteAPI requests: When making requests to the ZMQRemoteAPI server or backend service, include the authentication token in the request headers or body. The server can validate the token to ensure that the request is coming from an authenticated user.</p>
<p>It's important to implement secure authentication practices, such as using strong passwords, secure token handling, encryption (HTTPS), and protecting against common security vulnerabilities like cross-site scripting (XSS) and cross-site request forgery (CSRF).</p>
<p>Please note that the specific implementation details will depend on your server-side technology stack and the authentication mechanisms you choose to use. You may also need to refer to the documentation of the frameworks or libraries you are using for more specific guidance.</p>
<p>Remember to follow best practices for secure authentication and consult with security experts if needed to ensure that your implementation meets your specific security requirements.</p>
<hr/>
<p><a href="/downloads/zmqRemoteApi_for_IPv6.7z">zmqRemoteApi_for_IPv6.7z</a></p>
<p>準備在 151 建立 copsim.cycu.org 10ff:151::1</p>
<p><a href="https://forum.coppeliarobotics.com/viewtopic.php?t=9294">https://forum.coppeliarobotics.com/viewtopic.php?t=9294</a> </p>
<p><a href="https://coppeliarobotics.com/helpFiles/en/dataVisualizationAndOutput.htm">https://coppeliarobotics.com/helpFiles/en/dataVisualizationAndOutput.htm</a> </p>
<p>能否在 headless 啟動 Visualization Stream function and open scene throught programming?</p>
<p>Reference:</p>
<p style="padding-left: 30px;">You can start CoppeliaSim passing the command line parameter -GzmqRemoteApi.rpcPort=23005.</p>
<p style="padding-left: 30px;">Or with CoppeliaSim already started, execute sim.setNamedInt32Param('zmqRemoteApi.rpcPort',23005) (e.g. in the lua commander at bottom of screen) and then restart the ZMQ Remote API server addon.</p>
<p>若將 simAddonVisualization stream.lua 中的 autoStart 設為 true, 則 Coppeliasim 啟動後將自動執行 Visualization stream server.</p>
<p>且若以 coppeliasim -h -s c:\tmp\mtb_robot.ttt 指定採 headless 方式啟動 (-h), 且自動執行 simulation (-s), 則可將此一指令設為 service 讓場景的執行隨操作系統啟動.</p>
<p>simAddOZMQ remoteAPI server.lua 中修改:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function zmqRemoteApi.verbose()
    -- return tonumber(sim.getStringNamedParam('zmqRemoteApi.verbose') or '0')
    -- set zmqRemoteApi server autoStart = true
    return tonumber(sim.getStringNamedParam('zmqRemoteApi.verbose') or '1')
end</pre>
<p>可讓 zmqRemoteAPI 隨系統啟動.<br/><br/></p>
<h3>Sensing</h3>
<p>Using zmqremoteAPI to sense object:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import zmqremoteapi

# Connect to CoppeliaSim through ZMQRemoteAPI
with zmqremoteapi.RemoteAPIClient('127.0.0.1', 23000) as client:  # Replace with the appropriate IP address
    # Start the simulation
    client.simxStartSimulation(zmqremoteapi.simx_opmode_blocking)

    # Get the handle of the proximity sensor in CoppeliaSim
    res, sensor_handle = client.simxGetObjectHandle('ProximitySensor', zmqremoteapi.simx_opmode_blocking)  # Replace 'ProximitySensor' with the actual sensor name
    
    if res == zmqremoteapi.simx_return_ok:
        # Main loop
        while True:
            # Read the proximity sensor's data
            res, detection_state, detected_object_handle, _, detected_object_position = client.simxReadProximitySensor(sensor_handle, zmqremoteapi.simx_opmode_blocking)

            if res == zmqremoteapi.simx_return_ok and detection_state:
                # Get the name of the detected object
                res, detected_object_name = client.simxGetObjectName(detected_object_handle, zmqremoteapi.simx_opmode_blocking)

                if res == zmqremoteapi.simx_return_ok:
                    # Get the type of the detected object
                    res, detected_object_type = client.simxGetObjectType(detected_object_handle, zmqremoteapi.simx_opmode_blocking)

                    if res == zmqremoteapi.simx_return_ok:
                        # Get the color of the detected object
                        res, _, detected_object_color, _, _ = client.simxGetObjectColor(detected_object_handle, -1, zmqremoteapi.simx_opmode_blocking)

                        if res == zmqremoteapi.simx_return_ok:
                            # Display the sensed object's information
                            print("Detected Object:")
                            print("Name:", detected_object_name)
                            print("Type:", detected_object_type)
                            print("Color:", detected_object_color)
                            print("------------------")

            # Delay for a short period before the next sensing
            client.simxSpinOnce()

    # Stop the simulation
    client.simxStopSimulation(zmqremoteapi.simx_opmode_blocking)
</pre>
<h2>Brython_ws</h2>
<p><a href="https://www.piesocket.com/websocket-tester">Brython WebSocket tester</a></p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1});
}
</script>
<button id="openbtn">Open connection</button> <br/><input id="data" type="text"/><button disabled="disabled" id="sendbtn">Send</button></p>
<p><button disabled="disabled" id="closebtn">Close connection</button>
<script type="text/python">
from browser import bind, document, websocket
from browser.widgets.dialog import InfoDialog

def on_open(evt):
    document['sendbtn'].disabled = False
    document['closebtn'].disabled = False
    document['openbtn'].disabled = True
    InfoDialog("websocket", f"Connection open")    

def on_message(evt):
    # message received from server
    InfoDialog("websocket", f"Message received : {evt.data}")

def on_close(evt):
    # websocket is closed
    InfoDialog("websocket", "Connection is closed")
    document['openbtn'].disabled = False
    document['closebtn'].disabled = True
    document['sendbtn'].disabled = True

ws = None

@bind('#openbtn', 'click')
def _open(ev):
    if not websocket.supported:
        InfoDialog("websocket", "WebSocket is not supported by your browser")
        return
    global ws
    # open a web socket
    ws = websocket.WebSocket("wss://demo.piesocket.com/v3/channel_123?api_key=VCXCEuvhGcBDP7XhiJJUDvR1e1D3eiVjgZ9VRiaV&notify_self")
    # bind functions to web socket events
    ws.bind('open',on_open)
    ws.bind('message',on_message)
    ws.bind('close',on_close)

@bind('#sendbtn', 'click')
def send(ev):
    data = document["data"].value
    if data:
        ws.send(data)

@bind('#closebtn', 'click')
def close_connection(ev):
    ws.close()
    document['openbtn'].disabled = False
</script>
</p><h1>Brython</h1>
<p><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">https://en.wikipedia.org/wiki/Python_(programming_language)</a></p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d">https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d</a></p>
<p style="padding-left: 30px;"><a href="https://www.geeksforgeeks.org/python-programming-examples/">https://www.geeksforgeeks.org/python-programming-examples/</a></p>
<p style="padding-left: 30px;"><a href="https://www.programiz.com/python-programming/examples">https://www.programiz.com/python-programming/examples</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/">https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/</a></p>
<h4>Python Tutorial:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a></p>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/introduction.html">An informal introduction to Python</a></p>
<h4>Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍)</h4>
<h4>Variables (<a href="https://github.com/python/cpython/blob/3.11/Lib/keyword.py">Python Keywords</a>)</h4>
<h4>Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解)</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#numbers">Numbers</a> (整數 int(), 浮點數 float())</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#strings">Strings</a> (字串)</h4>
<h4>print (Python 內建函式, <a href="https://docs.python.org/3/library/functions.html#print">print()</a> 函式)</h4>
<p><a href="https://docs.python.org/3/tutorial/controlflow.html">Python control flow tools</a></p>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements">for</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements">if</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function">range</a></h4>
<h4>open</h4>
<h4>read</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#lists">lists</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">tuples</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">functions</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/errors.html#exceptions">try ... except</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">break</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#pass-statements">pass</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/classes.html?highlight=classes">classes</a></h4>
<p>這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 (<a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件).</p>
<p><a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用.</p>
<p>亦即將所有對應的 html 也使用 Brython 產生, 然後寫為 <a href="https://docs.python.org/3/tutorial/classes.html">class</a> 後, 在範例導入時透過 <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects">instance</a> 引用.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
&lt;/script&gt;</pre>
<p>從 1 累加到 100:</p>
<p><button id="add1to100">1 add to 100</button></p>
<p>將 iterable 與 iterator <a href="https://home.gamer.com.tw/creationDetail.php?sn=4337438">相關說明</a>, 利用 Brython 與 Ace Editor 整理在這個頁面.</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button><button id="threejsblock">Rotating Block</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
################################## threejsblock start
threejsblock_url = "https://gist.githubusercontent.com/mdecycu/2c6323eff49b496d1bafd210f3ec9707/raw/df37802f9e8a386b6424f7945af622b1cd0a9ca5/threejs_rotating_block.py"
threejsblock = button2(threejsblock_url)
doc["threejsblock"].bind("click", threejsblock.do)
################################## threejsblock end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>
<h2>Brython_ex2</h2>
<p>This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5.</p>
<p id="brython_div"></p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<p>Solve ODE:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new paragraph element and set its text content to the solution
p = document.createElement('p')
p.textContent = f"The solution to the ODE is: {y}"

# Append the paragraph element to the body of the webpage
document.body.appendChild(p)</pre>
<p></p>
<p>
<script type="text/python3">
from browser import document, window

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new div element to hold the plot
#plot_div = document.createElement('div')
#plot_div.id = 'plot'
#document.body.appendChild(plot_div)
plot_div = document["brython_div"]

# Plot the solution using plotly.js
data = [{'x': x, 'y': y}]
window.Plotly.newPlot('brython_div', data)
</script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</p>
<p>Brython environment and <a href="https://plotly.com/javascript/">Plotly.js</a>:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
// ]]&gt;&lt;/script&gt;
&lt;p id="brython_div"&gt;&lt;/p&gt;</pre>
<p>Brython programe with Plotly.js:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, window

def dy_dx(y, x):
    return x - y

x_start = 0
x_end = 5
n_points = 100
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = 1.0
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))

# Create a new div element to hold the plot
#plot_div = document.createElement('div')
#plot_div.id = 'plot'
#document.body.appendChild(plot_div)
plot_div = document["brython_div"]

# Plot the solution using plotly.js
data = [{'x': x, 'y': y}]
window.Plotly.newPlot('brython_div', data)</pre>
<p>This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using <a href="https://plotly.com/javascript/">plotly.js</a>.</p>
<p id="mass-spring-damper"></p>
<p>
<script type="text/python3">
from browser import document, window

m = 1.0  # mass
k = 1.0  # spring constant
c = 0.1  # damping coefficient

def dy_dx(y, x):
    y1, y2 = y
    return [y2, -(k/m)*y1 - (c/m)*y2]

x_start = 0
x_end = 20
n_points = 1000
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = [1.0, 0.0]
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y_new = [y[-1][j] + h * dy_dx(y[-1], x[i-1])[j] for j in range(2)]
    y.append(y_new)

# Create a new div element to hold the plot
'''
plot_div = document.createElement('div')
plot_div.id = 'plot'
document.body.appendChild(plot_div)
'''

# Plot the solution using plotly.js
data = [{'x': x, 'y': [y[i][0] for i in range(len(y))]}]
layout = {'title': 'Mass-Spring-Damper System', 'xaxis': {'title': 'Time'}, 'yaxis': {'title': 'Displacement'}}
window.Plotly.newPlot('mass-spring-damper', data, layout)
</script>
</p>
<p>This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using <a href="https://plotly.com/javascript/">plotly.js</a>.</p>
<p id="pid-control"></p>
<p>
<script type="text/python3">
from browser import document, window

m = 1.0  # mass
k = 1.0  # spring constant
c = 0.1  # damping coefficient

Kp = 10.0  # proportional gain
Ki = 1.0   # integral gain
Kd = 0.5   # derivative gain

def dy_dx(y, x):
    y1, y2, e_int, e_prev = y
    e = 1 - y1
    de_dt = -y2
    u = Kp * e + Ki * e_int + Kd * de_dt
    return [y2, (u - k*y1 - c*y2)/m, e, e]

x_start = 0
x_end = 20
n_points = 1000
x = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]
y0 = [0.0, 0.0, 0.0, 0.0]
h = x[1] - x[0]
y = [y0]
for i in range(1, len(x)):
    y_new = [y[-1][j] + h * dy_dx(y[-1], x[i-1])[j] for j in range(4)]
    y.append(y_new)

'''
# Create a new div element to hold the plot
plot_div = document.createElement('div')
plot_div.id = 'plot'
document.body.appendChild(plot_div)
'''

# Plot the solution using plotly.js
data = [{'x': x, 'y': [y[i][0] for i in range(len(y))], 'name': 'Output'},
        {'x': x, 'y': [1 for _ in range(len(y))], 'name': 'Setpoint'}]
layout = {'title': 'Mass-Spring-Damper System with PID Control', 'xaxis': {'title': 'Time'}, 'yaxis': {'title': 'Displacement'}}
window.Plotly.newPlot('pid-control', data, layout)
</script>
</p>
<p height="480" id="container" width="640"></p>
<p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" type="text/javascript"></script>
<script type="text/python">
from browser import document, window

# Set up the Three.js scene
container = document['container']
scene = window.THREE.Scene.new()
camera = window.THREE.PerspectiveCamera.new(75, 640 / 480, 0.1, 1000)
renderer = window.THREE.WebGLRenderer.new()
renderer.setSize(640, 480)
container <= renderer.domElement

# Create a cube
geometry = window.THREE.BoxGeometry.new(1, 1, 1)
material = window.THREE.MeshBasicMaterial.new({'color': 0x00ff00})
cube = window.THREE.Mesh.new(geometry, material)
scene.add(cube)

# Move the camera back so we can see the cube
camera.position.z = 5

# Define the animation loop
def animate(timestamp):
    # Rotate the cube
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    
    # Render the scene
    renderer.render(scene, camera)
    
    # Request the next frame
    window.requestAnimationFrame(animate)

# Start the animation loop
window.requestAnimationFrame(animate)
</script>
</p>
<p height="480" id="container2" width="640"></p>
<p>
<script type="text/python">
from browser import document, window

# Set up the Three.js scene
container = document['container2']
scene = window.THREE.Scene.new()
camera = window.THREE.PerspectiveCamera.new(75, 640 /480, 0.1, 1000)
renderer = window.THREE.WebGLRenderer.new()
renderer.setSize(640, 480)
container <= renderer.domElement

# Create a cube
geometry = window.THREE.BoxGeometry.new(1, 1, 1)
material = window.THREE.MeshBasicMaterial.new({'color': 0x00ff00})
cube = window.THREE.Mesh.new(geometry, material)
scene.add(cube)

# Move the camera back so we can see the cube
camera.position.z = 5

# Set up a Raycaster for mouse interaction
raycaster = window.THREE.Raycaster.new()
mouse = window.THREE.Vector2.new()

# Define a function to handle mouse move events
def on_mouse_move(event):
    # Calculate the mouse position in normalized device coordinates
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

# Register the mouse move event handler
document.bind('mousemove', on_mouse_move)

# Define the animation loop
def animate(timestamp):
    # Update the Raycaster with the current mouse position
    raycaster.setFromCamera(mouse, camera)
    
    # Check if the Raycaster intersects with the cube
    intersects = raycaster.intersectObject(cube)
    
    # Change the cube color if it is intersected
    if len(intersects) > 0:
        cube.material.color.set(0xff0000)
    else:
        cube.material.color.set(0x00ff00)
    
    # Rotate the cube
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    
    # Render the scene
    renderer.render(scene, camera)
    
    # Request the next frame
    window.requestAnimationFrame(animate)

# Start the animation loop
window.requestAnimationFrame(animate)
</script>
</p>
<p>STL part viewer</p>
<p height="480" id="stl" width="640"></p>
<p>
<script type="text/python">
from browser import document, html

# Create a container for the STL viewer
stl_container = html.DIV(id="stl_cont")
stl = document["stl"]
stl <= stl_container

# Load the Stl Viewer Javascript Plugin
stl_viewer_script = html.SCRIPT(src="https://www.viewstl.com/plugin/stl_viewer.min.js")
stl <= stl_viewer_script

def init_stl_viewer():
    # Create a new instance of Stl Viewer
    stl_viewer = window.StlViewer.new(document.getElementById("stl_cont"), {"models": [{"id": 0, "filename": "/downloads/block100.stl"}]})

# Wait for the Stl Viewer Javascript Plugin to load before initializing the viewer
document.bind("readystatechange", lambda: init_stl_viewer() if document.readyState == "complete" else None)
</script>
</p>
<p>Using <a href="https://www.sciencedirect.com/science/article/pii/S0950705115005043">sine-cosine algorithm</a> to optimize with constraints in Brython:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython()"&gt;

&lt;div id="output"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
from browser import document
from random import random, uniform
from math import sin, cos, pi

# Define the objective function
def objective_function(x):
    return x[0]**2 + x[1]**2

# Define the constraint functions
def constraint1(x):
    return x[0] + x[1] - 2

def constraint2(x):
    return 1 - x[0] - x[1]

# Define the penalty function
def penalty_function(x):
    penalty = 0
    if constraint1(x) &gt; 0:
        penalty += constraint1(x)
    if constraint2(x) &gt; 0:
        penalty += constraint2(x)
    return penalty

# Define the fitness function
def fitness_function(x):
    return objective_function(x) + penalty_function(x)

# Define the sine cosine algorithm
def sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):
    # Initialize the population
    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]
    population_fitness = [fitness_function(individual) for individual in population]

    # Initialize the best solution
    best_solution = population[0]
    best_fitness = population_fitness[0]

    # Main loop of the algorithm
    for iteration in range(max_iterations):
        # Calculate the value of a and r1
        a = 2 - iteration * (2 / max_iterations)
        r1 = 2 * pi * random()

        # Update the population
        for i in range(population_size):
            # Calculate the value of r2, r3 and r4
            r2 = 2 * random()
            r3 = 2 * random()
            r4 = random()

            # Update the individual
            for j in range(dimension):
                if r4 &lt; 0.5:
                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])
                else:
                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])

                # Make sure the individual is within the bounds
                if population[i][j] &lt; lower_bound:
                    population[i][j] = lower_bound
                elif population[i][j] &gt; upper_bound:
                    population[i][j] = upper_bound

            # Calculate the fitness of the individual
            population_fitness[i] = fitness_function(population[i])

            # Update the best solution
            if population_fitness[i] &lt; best_fitness:
                best_solution = population[i]
                best_fitness = population_fitness[i]

        # Print the current iteration and best fitness
        print(f'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}')

    return best_solution

# Run the sine cosine algorithm to solve the optimization problem with constraints
best_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)

# Print the result
output_div = document['output']
output_div.text = f'Best Solution: {best_solution}'
&lt;/script&gt;

&lt;script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>Plot the result by using <a href="https://plotly.com/javascript/">plotly.js</a>:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.plot.ly/plotly-latest.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython()"&gt;

&lt;div id="output"&gt;&lt;/div&gt;
&lt;div id="plot"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
from browser import document
from random import random, uniform
from math import sin, cos, pi

# Define the objective function
def objective_function(x):
    return x[0]**2 + x[1]**2

# Define the constraint functions
def constraint1(x):
    return x[0] + x[1] - 2

def constraint2(x):
    return 1 - x[0] - x[1]

# Define the penalty function
def penalty_function(x):
    penalty = 0
    if constraint1(x) &gt; 0:
        penalty += constraint1(x)
    if constraint2(x) &gt; 0:
        penalty += constraint2(x)
    return penalty

# Define the fitness function
def fitness_function(x):
    return objective_function(x) + penalty_function(x)

# Define the sine cosine algorithm
def sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):
    # Initialize the population
    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]
    population_fitness = [fitness_function(individual) for individual in population]

    # Initialize the best solution
    best_solution = population[0]
    best_fitness = population_fitness[0]

    # Main loop of the algorithm
    for iteration in range(max_iterations):
        # Calculate the value of a and r1
        a = 2 - iteration * (2 / max_iterations)
        r1 = 2 * pi * random()

        # Update the population
        for i in range(population_size):
            # Calculate the value of r2, r3 and r4
            r2 = 2 * random()
            r3 = 2 * random()
            r4 = random()

            # Update the individual
            for j in range(dimension):
                if r4 &lt; 0.5:
                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])
                else:
                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])

                # Make sure the individual is within the bounds
                if population[i][j] &lt; lower_bound:
                    population[i][j] = lower_bound
                elif population[i][j] &gt; upper_bound:
                    population[i][j] = upper_bound

            # Calculate the fitness of the individual
            population_fitness[i] = fitness_function(population[i])

            # Update the best solution
            if population_fitness[i] &lt; best_fitness:
                best_solution = population[i]
                best_fitness = population_fitness[i]

        # Print the current iteration and best fitness
        print(f'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}')

    return best_solution

# Run the sine cosine algorithm to solve the optimization problem with constraints
best_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)

# Print the result
output_div = document['output']
output_div.text = f'Best Solution: {best_solution}'

# Plot the result using Plotly.js
data = [
    {
        'x': [best_solution[0]],
        'y': [best_solution[1]],
        'mode': 'markers',
        'marker': {'size': 12},
        'name': 'Best Solution'
    }
]

layout = {
    'xaxis': {'range': [-10, 10]},
    'yaxis': {'range': [-10, 10]},
}

Plotly.newPlot('plot', data, layout)
&lt;/script&gt;

&lt;script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p></p>