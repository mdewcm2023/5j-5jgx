var tipuesearch = {"pages": [{'title': 'About', 'text': '精密機械設計工程師的三個電腦網路與程式端: 近端、中端與遠端 . \n \n 近端帶有各種可攜帶且開源的程式套件與工具 (能編譯 C, C++, 解譯 Javascript, Python 與 Lua 的 USB 隨身碟或筆電系統) \n 中端即工作站室, 其中包含各種自行安裝配置的虛擬電腦主機 (Windows and Linux servers) \n 遠端即雲端, 其中包含各大公司所提供的免費或付費服務 (Github, Onedrive, Repllit,\xa0Azure, AWS) \n \n \n 2009 年啟用的電腦配置 8GB 安裝 Ubuntu 22.04 操作系統, 以 Nginx 伺服靜態系統, 以 wsgi 伺服動態系統. \n Repo:  https://github.com/mdewcm2023/5j-5jgx \n site:  https://mdewcm2023.github.io/5j-5jgx \n on cad2:  http://cad2.cycu.org/~yen/5jgx/ \n on cad2 account jgx:  http://cad2.cycu.org/~jgx/5jgx \n w11 如何在 cad2 主機上建立各分組的靜態網站.mp4 \n on cad2:  https://cad2.cycu.org:8001  from hupper -m server.py \n ssh-keygen:  https://mde.tw/blog/2022_fall_courses_w10.html \n sudo apt install ncat \n SSH setup: \n .ssh/config \n Host github.com\nUser git\nHostname github.com\nProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p \n need to chmod u+x ./acp \n', 'tags': '', 'url': 'About.html'}, {'title': '精密機械', 'text': '學長   2021 年發表的論文 \n', 'tags': '', 'url': '精密機械.html'}, {'title': '程式開發', 'text': '下載 MSYS2 and Cmake.7z  (下載 3.47GB 解開後 12.6GB, for @nfu users only) \n 在計算機程式開發過程中學習英文、演算法、資料結構與資料庫 (SQLite and PostgreSQL) \n Data structures and algorithms \n Python Algorithms  (for @nfu users only) \n Problem Solving with Algorithms and Data Structures \n Javascript (在瀏覽器中學習) \n Python (Brython) - 以 Brython 接續 Javascript 在網頁中用 Brython 解題, 透過網路與 Server 端的 Python 程式互動, 而 Server 端的 Python 則可再與 MCAD API 互動 (SolidWorks, Solid Edge, NX 等) \n ANSIC (Arduino) - 從 Arduino 硬體控制 C 程式學習與 Server 端的 Python 程式整合 \n C++ (Solvespace) - 自行編譯 Solvespace, 建立 dll 與 Python 互動, 導入 Pyslvs-UI \n Lua (CoppeliaSim) - 虛實整合模擬與控制系統設計平台 \n MSYS2 與 Cmake - C 與 C++ 編譯器 \n \n 以 MSYS2 編譯 lua 原始碼:\xa0 \n REM 設定 msys2 64 位元的執行路徑 set path_msys2=%Disk%:\\msys64_20210419\\mingw64\\bin; \n Lua 原始碼 - 以 ANSI C 編寫 \n 下載後解開壓縮檔案, 進入原始碼目錄後執行: \n make PLAT=mingw \n 即可在 src 目錄中取得\xa0lua.exe, luac.exe, lua53.dll 以及 liblua.a (以 lua 5.3.5 為例) \n \n 因為 CoppeliaSim 透過 simExtWS.dll (Websocket extension server), simAddonVisualization stream.lua 以及 threejsFrontend.js 讓使用者可以在啟動 Visualization stream 伺服器後, 由瀏覽器的特定 port (內定為 23020) 取得 threejsFrontend.html 頁面 client 程式與 server 端傳遞場景模擬串流資料, 可以讓多人即時觀看場景模擬. \n 內建的 simAddonVisualization stream.lua 僅讓 client 端以 HTTP request 場景物件串流資料 (即透過 ws:// 發出 requests), 若要讓 client 以 HTTPS request 發出 requests (即改透過 wss://), 則 simAddonVisualization stream.lua 必須建立 SSL 架構的 server, 這時就需要 Lua 帶有 ssl 或 luasec 模組才行. \n 因此自行編譯 lua 原始碼的用意即在設法根據需求延伸 CoppeliaSim 的功能.', 'tags': '', 'url': '程式開發.html'}, {'title': 'Javascript', 'text': "The best way to learn Javascript: Learning JavaScript is a great way to get started with web development, as it is a powerful and versatile programming language used in many different applications. Here are some tips on how to learn JavaScript effectively: 1. Start with the basics: Before diving into complex frameworks or libraries, make sure you have a solid foundation of the basics of JavaScript. This includes understanding variables, data types, functions, loops, and conditional statements. 2. Practice coding: The best way to learn JavaScript is to practice coding. This means writing your own code, working on exercises and projects, and experimenting with different concepts. 3. Use online resources: There are many online resources available for learning JavaScript, including video tutorials, online courses, and documentation. Some popular options include Codecademy, FreeCodeCamp, and Mozilla Developer Network. 4. Join a community: Joining a community of JavaScript learners can be helpful for getting support and feedback on your code, as well as learning from others. You can join online communities such as Stack Overflow, Reddit, or GitHub. 5. Build projects: Building projects is a great way to apply what you've learned and gain practical experience with JavaScript. Start with small projects and gradually increase the complexity as you become more comfortable with the language. 6. Keep learning: JavaScript is constantly evolving, so it's important to stay up to date with the latest updates and trends. Subscribe to newsletters, follow blogs and podcasts, and attend conferences to continue your learning journey. To have a solid foundation of the basics of JavaScript, you can follow these steps: 1. Read the documentation: Start by reading the official documentation for JavaScript. This will give you a thorough understanding of the language's syntax, data types, functions, and more.  The Mozilla Developer Network has an excellent JavaScript Guide  that covers all the basics. 2. Follow a structured course: Online courses, such as Codecademy or FreeCodeCamp, can provide a structured way to learn the basics of JavaScript. These courses often include interactive exercises and projects to help you practice what you've learned. 3. Practice coding: To solidify your understanding of the basics, you need to practice coding. You can start by writing simple programs that utilize variables, data types, functions, loops, and conditional statements. As you practice, gradually increase the complexity of your programs. 4. Review code examples: Reading and analyzing code examples can help you understand how the basics of JavaScript are used in practice. You can find examples on websites like GitHub or by reading through the source code of popular JavaScript libraries and frameworks. 5. Get feedback: Getting feedback on your code from other developers can help you identify areas for improvement and solidify your understanding of the basics. Joining online communities, like Stack Overflow, can be a good way to get feedback on your code and ask questions. \n References: \n https://eloquentjavascript.net/ \n http://jsforcats.com/ \n https://github.com/getify/You-Dont-Know-JS \n", 'tags': '', 'url': 'Javascript.html'}, {'title': 'TOEIC', 'text': '多益（TOEIC）是一種用於測試非英語為母語人士英語語言能力的標準化考試。它是由ETS（Educational Testing Service）組織開發的，旨在評估考生的英語聽力和閱讀能力，用於在全球範圍內衡量英語語言能力。 多益考試分為兩個部分：聽力和閱讀。聽力部分包括聆聽錄音並回答問題，閱讀部分包括閱讀文章並回答問題。考試時間為2小時，總分為990分，聽力和閱讀各佔50%。 多益考試通常用於衡量非英語國家的學生、畢業生和職業人士的英語水平。許多公司和學校使用多益考試作為聘請和錄取員工和學生的標準，以衡量他們的英語水平。 \n TOEIC 代表 "Test of English for International Communication"，翻譯成中文是「國際英語溝通測驗」。 \n TOEIC 包含兩種題型：單選題和填充題。其中，閱讀部分是以單選題為主，聽力部分則是以填充題和單選題結合的形式出現。閱讀部分的單選題是選出最適合或最相符的答案，填充題是根據題目要求填入適當的單詞或短語。聽力部分的填充題是根據所聽到的對話或短文內容填空，單選題是選出最適合或最相符的答案。 \n TOEIC 的選擇題不會有倒扣，也就是說，考生選擇了錯誤的答案不會扣除分數。每個題目都有唯一正確的答案，考生選擇了正確的答案可以得到相應的分數，選擇了錯誤的答案則不會得分。因此，建議考生如果對一道題目不確定答案，也可以根據猜測選擇一個選項，以增加得分的機會。 \n', 'tags': '', 'url': 'TOEIC.html'}, {'title': 'nginx', 'text': '設定 public_html \n https://www.server-world.info/en/note?os=Ubuntu_20.04&p=nginx&f=4 \n r: 4, w: 2, x: 1 \n 外部 711 - user rwx, group x, other x \n public_html 755 - user rwx, group rx, other rx \n \n \n', 'tags': '', 'url': 'nginx.html'}, {'title': 'Downloads', 'text': 'OBS:  https://obsproject.com/download \n Virtualbox:  https://www.virtualbox.org/wiki/Downloads \n wcm_portable_w2-5.7z  (下載 220MB 解開後 880MB) \n', 'tags': '', 'url': 'Downloads.html'}, {'title': 'OBS', 'text': '由於 OBS 會將 setting 存入 AppData 目錄, 因此要在隨身碟中保有先前的設定, 必須透過可攜系統的 command 啟動 obs. \n 議題: 如何設定鍵盤快捷鍵, 讓啟動與關閉錄影過程不會顯示在錄製的影片中. \n 議題: 手機可以做為 OBS 的一個 camera 來源嗎? \n 議題: OBS 可以透過 Youtube 或其他雲端網站進行 live streaming (現場串流直播) \n 利用程式控制 OBS: \n https://docs.obsproject.com/scripting \n \n', 'tags': '', 'url': 'OBS.html'}, {'title': 'cmsimde', 'text': '', 'tags': '', 'url': 'cmsimde.html'}, {'title': 'Upload', 'text': '\n \n \n \n 準備在 Server 端加上 image files rename 功能. \n Since the resolution of mobile phone camera is quite high, in order to get the resonable resolution images file upload for cmsimde based CMS, image files needed to reduce before uploading. \n Add the following functions to axuploader.js: \n // Function to resize an image\nfunction resizeImage(file, maxWidth, callback) {\n  // Create a new FileReader object\n  const reader = new FileReader();\n\n  // Add an event listener to the FileReader object that listens for when the file is loaded\n  reader.addEventListener("load", () => {\n    // Create a new image object\n    const img = new Image();\n\n      // Add an event listener to the image object that listens for when the image is loaded\n      img.addEventListener("load", () => {\n      var ratio = Math.min(maxWidth / img.width);\n      // Create a new canvas object\n      const canvas = document.createElement("canvas");\n\n      // Set the canvas width and height to the new width and height of the image\n\t  canvas.width = img.width * ratio;\n\t  canvas.height = img.height * ratio;\n\n      // Draw the image onto the canvas with the new width and height\n      const ctx = canvas.getContext("2d");\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n      // Convert the canvas to a data URL\n      const dataUrl = canvas.toDataURL("image/jpeg");\n\n      // Create a new file object from the data URL\n      const resizedFile = dataURLtoFile(dataUrl, file.name);\n\n      // Return the resized file\n      callback(resizedFile);\n    });\n\n    // Set the source of the image object to the data URL of the file\n    img.src = reader.result;\n  });\n\n  // Read the file as a data URL\n  reader.readAsDataURL(file);\n}\n\n// Function to convert a data URL to a file object\nfunction dataURLtoFile(dataUrl, filename) {\n  const arr = dataUrl.split(",");\n  const mime = arr[0].match(/:(.*?);/)[1];\n  const bstr = atob(arr[1]);\n  let n = bstr.length;\n  const u8arr = new Uint8Array(n);\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n  return new File([u8arr], filename, { type: mime });\n} \n', 'tags': '', 'url': 'Upload.html'}, {'title': 'ax5', 'text': 'using ax5: \n var uploader = new ax5.ui.uploader({\n  target: $(\'[data-ax5uploader="basic"]\'),\n  form: {\n    action: "/upload",\n    fileName: "file"\n  },\n  multiple: true,\n  manualUpload: true,\n  onprogress: function () {},\n  onuploaderror: function () {},\n  onuploaded: function () {}\n});\n\nuploader.on(\'beforeUpload\', function () {\n  var files = uploader.getFiles();\n  for (var i = 0; i < files.length; i++) {\n    var file = files[i];\n    var extension = file.name.split(\'.\').pop().toLowerCase();\n    if (extension == \'jpg\' || extension == \'png\' || extension == \'gif\') {\n      var img = new Image();\n      img.src = window.URL.createObjectURL(file);\n      img.onload = function () {\n        if (this.width > 800) {\n          var canvas = document.createElement(\'canvas\');\n          var ctx = canvas.getContext(\'2d\');\n          var ratio = 800 / this.width;\n          canvas.width = this.width * ratio;\n          canvas.height = this.height * ratio;\n          ctx.drawImage(this, 0, 0, canvas.width, canvas.height);\n          canvas.toBlob(function (blob) {\n            file = new File([blob], file.name, {type: file.type});\n          });\n        }\n      };\n    }\n  }\n});\n \n html side: \n <!DOCTYPE html>\n<html>\n<head>\n\t<meta charset="UTF-8">\n\t<title>My Web Application</title>\n\t<!-- include ax5 library from CDN -->\n\t<script src="https://cdn.rawgit.com/ax5ui/ax5core/master/dist/ax5core.min.js"></script>\n\t<script src="https://cdn.rawgit.com/ax5ui/ax5ui-datepicker/master/dist/ax5ui-datepicker.min.js"></script>\n\t<link rel="stylesheet" href="https://cdn.rawgit.com/ax5ui/ax5ui-datepicker/master/dist/ax5ui-datepicker.css">\n</head>\n<body>\n\t<!-- your web application content goes here -->\n</body>\n</html>\n \n ax5 works with Brython: \n from browser import document, alert\nimport ax5.ui.datepicker as datepicker\n\n# create a datepicker component\ndp = datepicker.create(\n  document["datepicker"],\n  {"mode": "date", "selectMode": "day", "control": {"left": "<", "yearTmpl": "%s", "monthTmpl": "%s"}},\n  {"onStateChanged": lambda e: alert(e["state"]["focusedDate"])},\n  {"minDate": "2020-01-01", "maxDate": "2023-12-31", "defaultDate": "2023-04-27"}\n)\n\n# show the datepicker component when the button is clicked\ndef show_datepicker(ev):\n  dp.popup()\n\ndocument["btn-show-datepicker"].bind("click", show_datepicker)\n \n html side: \n <!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <title>My Brython App</title>\n  <script src="https://cdn.jsdelivr.net/npm/brython@3.9.12/brython.min.js"></script>\n  <script src="https://cdn.jsdelivr.net/npm/ax5core@1.12.2/dist/ax5core.min.js"></script>\n  <script src="https://cdn.jsdelivr.net/npm/ax5ui-datepicker@1.0.1/dist/ax5ui-datepicker.min.js"></script>\n  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ax5ui-datepicker@1.0.1/dist/ax5ui-datepicker.css">\n</head>\n<body onload="brython()">\n  <button id="btn-show-datepicker">Show Datepicker</button>\n  <div id="datepicker"></div>\n  <script type="text/python">\n    # your Python code goes here\n  </script>\n</body>\n</html>\n \n Create pull-down menu by using ax5 and Brython: \n from browser import document, alert\nimport ax5.ui.menu as menu\n\n# define the menu items\nmenu_items = [\n    {"label": "Item 1", "value": "item1"},\n    {"label": "Item 2", "value": "item2"},\n    {"label": "Item 3", "value": "item3"},\n    {"label": "Item 4", "value": "item4"}\n]\n\n# create the menu component\nm = menu.create(\n    document["menu"],\n    {"theme": "default", "direction": "auto", "offset": {"left": 0, "top": 0}},\n    {"onSelect": lambda e: alert(e["selected"])},\n    menu_items\n)\n\n# show the menu component when the button is clicked\ndef show_menu(ev):\n    m.popup()\n\ndocument["btn-show-menu"].bind("click", show_menu)\n \n html side: \n <!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>My Brython App</title>\n    <script src="https://cdn.jsdelivr.net/npm/brython@3.9.12/brython.min.js"></script>\n    <script src="https://cdn.jsdelivr.net/npm/ax5core@1.12.2/dist/ax5core.min.js"></script>\n    <script src="https://cdn.jsdelivr.net/npm/ax5ui-menu@1.0.7/dist/ax5ui-menu.min.js"></script>\n    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ax5ui-menu@1.0.7/dist/ax5ui-menu.css">\n</head>\n<body onload="brython()">\n    <button id="btn-show-menu">Show Menu</button>\n    <div id="menu"></div>\n    <script type="text/python">\n        # your Python code goes here\n    </script>\n</body>\n</html>\n \n Using axios: \n from browser import document, ajax\nimport axios\n\n# function to handle form submission\ndef submit_form(ev):\n    ev.preventDefault()  # prevent default form submission\n    form_data = FormData(document["my-form"])  # create FormData object from form\n    axios.post("/submit", data=form_data)  # send form data to Flask server\n\ndocument["my-form"].bind("submit", submit_form)\n \n Flask side: \n from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\'/submit\', methods=[\'POST\'])\ndef submit():\n    file = request.files[\'file\']  # get the file object from the request\n    # process the file object here\n    return \'File uploaded successfully\'\n\nif __name__ == \'__main__\':\n    app.run()\n \n Using axios and Brython to GET: \n import axios\n\naxios.get(\'https://api.example.com/data\')\n    .then(function(response) {\n        console.log(response.data);\n    })\n    .catch(function(error) {\n        console.error(error);\n    });\n \n axios and traditional XMLHttpRequest (XHR) (also known as AJAX) are both ways to make HTTP requests in JavaScript. While both can be used to accomplish similar tasks, axios provides a number of advantages over traditional AJAX: \n \n Promise-based API: axios uses a promise-based API, which makes it easier to manage asynchronous code and handle errors. \n Automatic request cancellation: axios allows you to cancel requests that are in progress, which can help to improve performance and reduce network traffic. \n Intercepting requests and responses: axios allows you to intercept requests and responses, which can be useful for adding authentication headers, logging, or modifying requests or responses. \n Support for Cross-site requests: axios includes built-in support for cross-site requests (CSRF) protection, which is important for security when making requests to a different domain than the one hosting the page. \n Simpler syntax: axios provides a simpler and more consistent API for making requests than traditional AJAX. \n \n Overall, axios provides a more modern and convenient way to make HTTP requests than traditional AJAX, and is widely used and well-documented. However, there are still situations where traditional AJAX may be more appropriate, depending on the specific requirements of your application. \n axios was developed by Matt Zabriskie, a web developer based in New York City. It was originally released in 2014 as an alternative to the jQuery.ajax() function, and has since become a popular library for making HTTP requests in JavaScript applications. The project is open source and hosted on GitHub, where it is maintained by a community of contributors. The library is licensed under the MIT license, which allows for free use and modification of the code in both open source and commercial projects. \n', 'tags': '', 'url': 'ax5.html'}, {'title': 'Games', 'text': 'Learn Python and Javascript: \n Python: \n python_beginners.pdf \n Programming Microcontrollers with Python  (2021) (必須使用校園網路(Proxy or VPN) 才能下載) \n Learn Raspberry Pi Programming with Python  (2014) (必須使用校園網路(Proxy or VPN) 才能下載) \n Javascript: \n Build Your Own 2D Game Engine and Create Great Web Games  (2022) (必須使用校園網路(Proxy or VPN) 才能下載) \n Brython:  https://brython.info/ \n https://brython.info/gallery/bricks_py.html \n https://brython.info/gallery/3Dwalker.html \n https://bmsleight.github.io/brython-blocks/ \n https://brython.info/gallery/taquin.html \n https://github.com/BrythonServer/ggame \n https://mde.tw/wcm2023/content/Reeborg.html \n', 'tags': '', 'url': 'Games.html'}, {'title': 'Note', 'text': '', 'tags': '', 'url': 'Note.html'}, {'title': 'w11', 'text': '單機場景加上計分 pj2bg14  ( repo ) 60 \n 修改標題, 加入學員 github 帳號, 以及 w11 下的學員網頁 \xa0\xa0\xa0\xa0\xa0 \n pj2bg1  ( repo ) X 41023246 pj2bg2  ( repo ) X pj2bg3  ( repo ) 41023252, 41023211 pj2bg4  ( repo ) X 41023201 pj2bg5  ( repo ) X pj2bg6  ( repo ) 41023226, 41023220 網頁標題未改, 41023233 pj2bg7  ( repo ) 41023228 網頁標題未改 41023219, 41023221 pj2bg8  ( repo ) X 41023242 pj2bg9  ( repo ) X pj2bg10  ( repo ) 41023241 無學員 github 帳號 pj2bg11  ( repo ) X pj2bg12  ( repo ) 41023251, 41023234 網頁標題未改 pj2bg13  ( repo ) X pj2bg14  ( repo ) X pj2bg15  ( repo ) X pj2bg16  ( repo ) X', 'tags': '', 'url': 'w11.html'}, {'title': 'wss', 'text': 'https://blog.heidt.biz/blog/2012/07/19/ssl-websocket-proxy-with-stunnel-howto/ \n https://stackoverflow.com/questions/15403905/warping-ratchet-with-stunnel \n https://stackoverflow.com/questions/25849193/php-websocket-redirect-with-stunnel \n simAddOnVisualization stream.lua \n \\3rdparty\\coppelia-ws-remote-api\\RemoteAPIClient.js \n ; Certificate/key is needed in server mode and optional in client mode\ncert = /path/to/<myCert>.pem\nkey = /path/to/<myKey>.key\n\n; Protocol version (all, SSLv2, SSLv3, TLSv1)\nsslVersion = all\n\n; Some security enhancements for UNIX systems - comment them out on Win32\nchroot = /var/run/stunnel/\n\n; PID is created inside the chroot jail\npid = /stunnel.pid\n\n; Some performance tunings\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n;compression = zlib\n\n; Some debugging stuff useful for troubleshooting\ndebug = 7\noutput = /var/log/stunnel/stunnel.log\n;foreground = yes\n\n; Use it for client mode\n;client = yes                     !! turn to server mode\n\n; Service-level configuration\n[wsServer]\naccept = 0.0.0.0:9030             !! listen to all addresses\nconnect = 127.0.0.1:9090 \n \n', 'tags': '', 'url': 'wss.html'}, {'title': 'Visualization', 'text': 'simExtWS 要先執行. \n SimAddonVisualization stream.lua 按下下拉式功能表之後顯示 running \n function sysCall_info()\n    autoStart=sim.getNamedBoolParam(\'visualizationStream.autoStart\')\n    if autoStart==nil then autoStart=false end\n    return {autoStart=autoStart,menu=\'Connectivity\\nVisualization stream\'}\nend\n\nfunction sysCall_init()\n    resourcesDir=sim.getStringParameter(sim.stringparam_resourcesdir)\n\n    if not simWS then\n        sim.addLog(sim.verbosity_errors,\'the WS plugin is not available\')\n        return {cmd=\'cleanup\'}\n    end\n\n    wsPort=sim.getNamedInt32Param(\'visualizationStream.ws.port\') or 23020\n    sim.addLog(sim.verbosity_scriptinfos,\'WS endpoint on port \'..tostring(wsPort)..\'...\')\n    if sim.getNamedBoolParam(\'visualizationStream.ws.retryOnStartFailure\') then\n        while true do\n            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)\n            if r then break end\n            sim.addLog(sim.verbosity_scriptwarnings,\'WS failed to start (\'..e..\'). Retrying...\')\n            sim.wait(0.5,false)\n        end\n    else\n        wsServer=simWS.start(wsPort)\n    end\n    simWS.setOpenHandler(wsServer,\'onWSOpen\')\n    simWS.setCloseHandler(wsServer,\'onWSClose\')\n    simWS.setMessageHandler(wsServer,\'onWSMessage\')\n    simWS.setHTTPHandler(wsServer,\'onWSHTTP\')\n    wsClients={}\n\n    cbor=require(\'org.conman.cbor\')\n    base64=require(\'base64\')\n    url=require(\'socket.url\')\n\n    sim.test(\'sim.mergeEvents\',true)\n    sim.test(\'sim.cborEvents\',true)\n\n    sim.addLog(sim.verbosity_scriptinfos,\'e.g. in your local web browser, type: http://127.0.0.1:\'..tostring(wsPort))\nend\n\nfunction sysCall_addOnScriptSuspend()\n    return {cmd=\'cleanup\'}\nend\n\nfunction sysCall_event(data)\n    sendEventRaw(data)\nend\n\nfunction sysCall_cleanup()\n    if wsServer then\n        simWS.stop(wsServer)\n    end\nend\n\nfunction getFileContents(path)\n    local f,err,errno=io.open(path,"rb")\n    if f then\n        local content=f:read("*all")\n        f:close()\n        return 200,content\n    else\n        return 404,nil\n    end\nend\n\nfunction onWSOpen(server,connection)\n    if server==wsServer then\n        wsClients[connection]=1\n        sendEventRaw(sim.getGenesisEvents(),connection)\n    end\nend\n\nfunction onWSClose(server,connection)\n    if server==wsServer then\n        wsClients[connection]=nil\n    end\nend\n\nfunction onWSMessage(server,connection,message)\nend\n\nfunction onWSHTTP(server,connection,resource,data)\n    resource=url.unescape(resource)\n    local mainPage=\'threejsFrontend\'\n    local status,data=404,nil\n    if resource==\'/\' or resource==\'/\'..mainPage..\'.html\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.html\')\n        if status==200 then\n            data=string.gsub(data,\'const wsPort = 23020;\',\'const wsPort = \'..wsPort..\';\')\n        end\n    elseif resource==\'/\'..mainPage..\'.js\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.js\')\n    elseif resource:sub(1,10)==\'/3rdparty/\' then\n        status,data=getFileContents(resourcesDir..resource)\n    end\n    if status==404 and resource~=\'/favicon.ico\' then\n        sim.addLog(sim.verbosity_errors,\'resource not found: \'..resource)\n    end\n    return status,data\nend\n\nfunction sendEventRaw(d,conn)\n    if d==nil then return end\n\n    if wsServer then\n        for connection,_ in pairs(wsClients) do\n            if conn==nil or conn==connection then\n                simWS.send(wsServer,connection,d,simWS.opcode.binary)\n            end\n        end\n    end\nend\n\nfunction verbose()\n    return sim.getNamedInt32Param(\'visualizationStream.verbose\') or 0\nend\n \n', 'tags': '', 'url': 'Visualization.html'}, {'title': 'WebSocket2', 'text': 'WebSocket - 維基百科，自由的百科全書 (wikipedia.org) \xa0 \n RFC 6455: The WebSocket Protocol (rfc-editor.org) \xa0 \n https://www.brython.info/static_doc/en/browser.websocket.html \xa0 \n Python之Websocket介紹與實作 \n WebSocket與Ajax的不同 \n Use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol  provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a web page to a remote server. \n 建立跨網際的虛實整合系統需要雙向傳遞即時資訊時使用.', 'tags': '', 'url': 'WebSocket2.html'}, {'title': 'Leo Editor', 'text': "Leo New User's Guide documentation \n", 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'Git', 'text': "測試在 acp 中加入 public_html 目錄中倉儲的 git pull 指令執行 \n fatal: \xa0Could not resolve host: github.com \n 發生原因: 目前的網路設定無法與 github.com 網站連線 \n 解決方法: \n 若使用 https 連線, 請檢查 home_ipv6 目錄下的 .gitconfig, 可能沒有設定 http.proxy \n 若使用 SSH 連線, 請檢查 Putty 設定的 session 中 Proxy, 可能沒有設定 http 對應的代理主機 \n cmsimde \n 準備利用\xa0 https://stackoverflow.com/questions/23945494/use-html5-to-resize-an-image-before-upload \xa0中所提供的方法在 5j-5jgx 倉儲中的 cmsimde 進行修改, 以便 resize image before uploading. \n To resize an image before uploading it using the jQuery AXuploader, you can use the following steps: \n \n Load the image using the FileReader API. \n Create an Image object and set its src property to the result of the FileReader API. \n for the onload event of the Image object to fire, indicating that the image has been fully loaded. \n Create a canvas element and set its dimensions to the desired size of the resized image. \n Draw the image onto the canvas using the drawImage method, passing in the Image object as the source and the canvas as the destination. \n Convert the canvas to a data URI using the toDataURL method. \n Convert the data URI to a Blob using the dataURItoBlob function. \n \n Here's an example implementation of the above steps: \n // define the maximum dimensions of the resized image\nconst MAX_WIDTH = 800;\nconst MAX_HEIGHT = 800;\n\n// define the dataURItoBlob function\nfunction dataURItoBlob(dataURI) {\n  const byteString = atob(dataURI.split(',')[1]);\n  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];\n  const ab = new ArrayBuffer(byteString.length);\n  const ia = new Uint8Array(ab);\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n  return new Blob([ab], { type: mimeString });\n}\n\n// handle the file upload\n$('#file-input').on('change', function() {\n  const file = this.files[0];\n  const reader = new FileReader();\n  reader.readAsDataURL(file);\n  reader.onload = function() {\n    const img = new Image();\n    img.onload = function() {\n      let width = img.width;\n      let height = img.height;\n\n      // calculate the new dimensions of the resized image\n      if (width > height) {\n        if (width > MAX_WIDTH) {\n          height *= MAX_WIDTH / width;\n          width = MAX_WIDTH;\n        }\n      } else {\n        if (height > MAX_HEIGHT) {\n          width *= MAX_HEIGHT / height;\n          height = MAX_HEIGHT;\n        }\n      }\n\n      // create a canvas and draw the resized image onto it\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n\n      // convert the canvas to a data URI and then to a Blob\n      const dataURL = canvas.toDataURL(file.type);\n      const blob = dataURItoBlob(dataURL);\n\n      // upload the resized image using the AXuploader\n      $.axuploader({\n        url: 'upload.php',\n        data: {\n          file: blob\n        },\n        success: function(response) {\n          console.log('Upload successful:', response);\n        },\n        error: function(xhr) {\n          console.error('Upload failed:', xhr.responseText);\n        }\n      });\n    };\n    img.src = reader.result;\n  };\n});\n \n In the above code, the MAX_WIDTH and MAX_HEIGHT constants define the maximum dimensions of the resized image. The dataURItoBlob function is a utility function that converts a data URI to a Blob. The change event of the file input element is handled to perform the image resizing and upload using the AXuploader. \n If server side is Flask based: \n from flask import Flask, request\nimport base64\nimport uuid\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload():\n    if 'file' in request.files:\n        file = request.files['file']\n        # process the uploaded file\n        if file:\n            # decode the base64 data\n            data = base64.b64decode(request.form['file_data'])\n\n            # save the data to a file\n            filename = str(uuid.uuid4()) + '.' + file.filename.split('.')[-1]\n            with open(os.path.join('uploads', filename), 'wb') as f:\n                f.write(data)\n\n            return 'Upload successful'\n    return 'Upload failed'\n \n In the above code, the Flask server defines a route /upload that receives a POST request containing the uploaded file data as a base64-encoded string in the request body. The code decodes the base64 data, generates a unique filename, and saves the data to a file in the uploads directory. The filename is returned as a response to indicate the successful upload. \n To make a request to this Flask endpoint from the client-side using jQuery AXuploader, you can modify the data option in the $.axuploader method to include the base64-encoded data: \n $.axuploader({\n    url: '/upload',\n    data: {\n        file_data: canvas.toDataURL(file.type).split(',')[1] // pass the base64-encoded data\n    },\n    success: function(response) {\n        console.log('Upload successful:', response);\n    },\n    error: function(xhr) {\n        console.error('Upload failed:', xhr.responseText);\n    }\n});\n \n In the above code, the file_data field is added to the data option of the $.axuploader method and its value is set to the base64-encoded data URI of the resized image. This data is sent to the Flask server as the request body of the POST request. The Flask server can then decode this data and save it to a file as shown in the previous code snippet. \n If file is uploaded chunk by chunk: \n Python \n from flask import Flask, request\nimport base64\nimport uuid\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload():\n    if 'file' in request.files:\n        file = request.files['file']\n        # process the uploaded file\n        if file:\n            # initialize the data buffer\n            data = b''\n            # read the chunks and append to the buffer\n            while True:\n                chunk = file.read(1024 * 1024) # read 1MB chunk\n                if not chunk:\n                    break\n                data += chunk\n\n            # decode the base64 data\n            data = base64.b64decode(request.form['file_data'])\n\n            # save the data to a file\n            filename = str(uuid.uuid4()) + '.' + file.filename.split('.')[-1]\n            with open(os.path.join('uploads', filename), 'wb') as f:\n                f.write(data)\n\n            return 'Upload successful'\n    return 'Upload failed'\n \n Javascript: \n $.axuploader({\n    url: '/upload',\n    data: {\n        file_data: canvas.toDataURL(file.type).split(',')[1] // pass the base64-encoded data\n    },\n    chunkSize: 1024 * 1024, // upload in 1MB chunks\n    success: function(response) {\n        console.log('Upload successful:', response);\n    },\n    error: function(xhr) {\n        console.error('Upload failed:', xhr.responseText);\n    }\n});\n", 'tags': '', 'url': 'Git.html'}, {'title': 'Coppeliasim', 'text': '當使用按下 Modules -> Connectivity ->Visualization stream 時, 系統呼叫位於 CoppeliaSim 套件根目錄中的 simAddOnVisualization stream.lua 檔案執行. 其中的 http server 是由 .lua 程式中的 function onWSHTTP(server,connection,resource,data)\xa0 \n Download CoppeliasimEdu_4.3.0rev12.7z  (for @nfu users only) \n Download CoppeliaSimEdu_4.5.1rev4.7z  (for@nfu users only) \n 因為 4.5.1 將 usrset.txt 存至 AppData\xa0 目錄下, 因此若設為可攜則必須從 C:\\users\\%USERNAME% 目錄中的 AppData\\Roaming\\CoppeliaSim 目錄取用相關設定, 因此首次設定完成後, 必須將 C:\\ 中的設定存至隨身碟, 且每次啟動可攜時, 再將此設定目錄從可攜檔案中, 以 xcopy 複製到 C:\\ 對應目錄. \n 必須加入 start_ipv6.bat 中的目錄複製指令: \n Xcopy %Disk%:\\home_ipv6\\AppData\\Roaming\\Coppeliasim C:\\users\\%USERNAME%\\AppData\\Roaming\\Coppeliasim /E /H /C /I /Y \n 這裡還需確認 4.5.1 版的 CoppeliaSim 設定檔案儲存位置為:\xa0 \n C:\\Users\\pj2023\\Documents\\Roaming\\CoppeliaSim \n 抑或: \n C:\\Users\\pj2023\\AppData\\Roaming\\CoppeliaSim \n \n 希望能在 https 與 wss 協定下啟動 Visualization Stream 功能 \n 由於 Coppeliasim 4.5.1 會將 usrset.txt 存入 AppData, 且只能使用 C:\\users 對應的帳號下 AppData, 因此使用隨身碟中的系統, 必須動用 xcopy 將存於隨身碟的相關設定寫入 C:\\ 對應區域, 才可使用滑鼠點擊開啟 CoppeliaSim, 但若以 Command 啟動 CoppeliaSim, 則部分的 plugin 無法存取, 例如: code editor plugin. \n Under simExtWS.dll \n Websocket server in lua: \n function onMessage(server,connection,data)\n    print(\'received:\',data)\n    data=\'Hello there\'\n    print(\'sending:\',data)\n    simWS.send(server,connection,data)\nend\n\nfunction sysCall_init()\n    server=simWS.start(9000)\n    simWS.setMessageHandler(server,\'onMessage\')\nend \n echo client in python \n import asyncio\nimport websockets\n\nasync def hello():\n    async with websockets.connect("ws://localhost:9000") as websocket:\n        payload = \'Hello, world!\'\n        print(\'Sending:\', payload)\n        await websocket.send(payload)\n        payload = await websocket.recv()\n        print(\'Received:\', payload)\n\nasyncio.run(hello())\n \n broadcasting server in lua: \n function onOpen(server,connection)\n    clients[server]=clients[server] or {}\n    clients[server][connection]=1\nend\n\nfunction onClose(server,connection)\n    clients[server][connection]=nil\nend\n\nfunction broadcast(data)\n    for server,connections in pairs(clients) do\n        for connection,_ in pairs(connections) do\n            simWS.send(server,connection,data)\n        end\n    end\nend\n\nfunction sysCall_init()\n    clients={}\n    server=simWS.start(9000)\n    simWS.setOpenHandler(server,\'onOpen\')\n    simWS.setCloseHandler(server,\'onClose\')\nend\n\nfunction sysCall_sensing()\n    local t=sim.getSimulationTime()\n    if lastBroadcastTime and (t-lastBroadcastTime)<1 then return end\n    lastBroadcastTime=t\n    i=(i or 0)+1\n    broadcast(\'#\'..i)\nend \n broadcasting client in python: \n import asyncio\nimport websockets\n\nasync def main():\n    async with websockets.connect("ws://localhost:9000") as websocket:\n        while True:\n            payload = await websocket.recv()\n            print(\'Received:\', payload)\n\nasyncio.run(main())\n \n http get server in lua: \n function onHTTP(server,connection,resource,data)\n    if resource==\'/\' then\n        local ua=sim.getStringNamedParam(\'simWS.userAgent\')\n        return 200,\'<html><body><h1>Index</h1><hr/><p>\'..ua..\'</p></body></html>\'\n    end\nend\n\nfunction sysCall_init()\n    clients={}\n    server=simWS.start(9000)\n    simWS.setHTTPHandler(server,\'onHTTP\')\nend\n \n Use browser  http://localhost:9000 \n \n simAddOnVisualization stream.lua \n function sysCall_info()\n    autoStart=sim.getNamedBoolParam(\'visualizationStream.autoStart\')\n    if autoStart==nil then autoStart=false end\n    return {autoStart=autoStart,menu=\'Connectivity\\nVisualization stream\'}\nend\n\nfunction sysCall_init()\n    resourcesDir=sim.getStringParameter(sim.stringparam_resourcesdir)\n\n    if not simWS then\n        sim.addLog(sim.verbosity_errors,\'the WS plugin is not available\')\n        return {cmd=\'cleanup\'}\n    end\n\n    wsPort=sim.getNamedInt32Param(\'visualizationStream.ws.port\') or 23020\n    sim.addLog(sim.verbosity_scriptinfos,\'WS endpoint on port \'..tostring(wsPort)..\'...\')\n    if sim.getNamedBoolParam(\'visualizationStream.ws.retryOnStartFailure\') then\n        while true do\n            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)\n            if r then break end\n            sim.addLog(sim.verbosity_scriptwarnings,\'WS failed to start (\'..e..\'). Retrying...\')\n            sim.wait(0.5,false)\n        end\n    else\n        wsServer=simWS.start(wsPort)\n    end\n    simWS.setOpenHandler(wsServer,\'onWSOpen\')\n    simWS.setCloseHandler(wsServer,\'onWSClose\')\n    simWS.setMessageHandler(wsServer,\'onWSMessage\')\n    simWS.setHTTPHandler(wsServer,\'onWSHTTP\')\n    wsClients={}\n\n    cbor=require(\'org.conman.cbor\')\n    base64=require(\'base64\')\n    url=require(\'socket.url\')\n\n    sim.test(\'sim.mergeEvents\',true)\n    sim.test(\'sim.cborEvents\',true)\n\n    sim.addLog(sim.verbosity_scriptinfos,\'e.g. in your local web browser, type: http://127.0.0.1:\'..tostring(wsPort))\nend\n\nfunction sysCall_addOnScriptSuspend()\n    return {cmd=\'cleanup\'}\nend\n\nfunction sysCall_event(data)\n    sendEventRaw(data)\nend\n\nfunction sysCall_cleanup()\n    if wsServer then\n        simWS.stop(wsServer)\n    end\nend\n\nfunction getFileContents(path)\n    local f,err,errno=io.open(path,"rb")\n    if f then\n        local content=f:read("*all")\n        f:close()\n        return 200,content\n    else\n        return 404,nil\n    end\nend\n\nfunction onWSOpen(server,connection)\n    if server==wsServer then\n        wsClients[connection]=1\n        sendEventRaw(sim.getGenesisEvents(),connection)\n    end\nend\n\nfunction onWSClose(server,connection)\n    if server==wsServer then\n        wsClients[connection]=nil\n    end\nend\n\nfunction onWSMessage(server,connection,message)\nend\n\nfunction onWSHTTP(server,connection,resource,data)\n    resource=url.unescape(resource)\n    local mainPage=\'threejsFrontend\'\n    local status,data=404,nil\n    if resource==\'/\' or resource==\'/\'..mainPage..\'.html\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.html\')\n        if status==200 then\n            data=string.gsub(data,\'const wsPort = 23020;\',\'const wsPort = \'..wsPort..\';\')\n        end\n    elseif resource==\'/\'..mainPage..\'.js\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.js\')\n    elseif resource:sub(1,10)==\'/3rdparty/\' then\n        status,data=getFileContents(resourcesDir..resource)\n    end\n    if status==404 and resource~=\'/favicon.ico\' then\n        sim.addLog(sim.verbosity_errors,\'resource not found: \'..resource)\n    end\n    return status,data\nend\n\nfunction sendEventRaw(d,conn)\n    if d==nil then return end\n\n    if wsServer then\n        for connection,_ in pairs(wsClients) do\n            if conn==nil or conn==connection then\n                simWS.send(wsServer,connection,d,simWS.opcode.binary)\n            end\n        end\n    end\nend\n\nfunction verbose()\n    return sim.getNamedInt32Param(\'visualizationStream.verbose\') or 0\nend\n \n threejsFrontend.js \n simAddonVisualization stream.lua modified: not work yet \n function sysCall_info()\n    autoStart=sim.getNamedBoolParam(\'visualizationStream.autoStart\')\n    if autoStart==nil then autoStart=false end\n\treturn {autoStart=autoStart,menu=\'Connectivity\\nVisualization stream (HTTPS)\'}\nend\n\nfunction sysCall_init()\n    addOnPath=sim.getStringParam(sim.stringparam_addonpath)\n    addOnBaseName=addOnPath:match("^.+/(.+).lua$")\n    addOnDir=addOnPath:match("^(.+)/.*")\n\n\tif not simWS then\n        sim.addLog(sim.verbosity_errors,\'the WS plugin is not available\')\n        return {cmd=\'cleanup\'}\n    end\n\n    wsPort = 443\n\t\n\tcertFile = "C:/CoppeliaSimEdu_4.3.0_rev12/localhost.crt"\n\tkeyFile = "C:/CoppeliaSimEdu_4.3.0_rev12/localhost.key"\n\t\n\tcert = assert(io.open(certFile, "r"))\n\tkey = assert(io.open(keyFile, "r"))\n\tssl_params = {cert = cert:read("*all"), key = key:read("*all")}\n\tcert:close()\n\tkey:close()\n\n    sim.addLog(sim.verbosity_scriptinfos,\'WS endpoint on port \'..tostring(wsPort)..\'...\')\n\n    wssServer = simWS.start(wsPort)\n\t\n\tsimWS.setOpenHandler(wssServer, \'onWSOpen\')\n\tsimWS.setCloseHandler(wssServer, \'onWSClose\')\n\tsimWS.setMessageHandler(wssServer, \'onWSMessage\')\n\tsimWS.setHTTPHandler(wssServer, \'onWSHTTP\')\n\twsClients = {}\n\n    cbor=require(\'org.conman.cbor\')\n    base64=require(\'base64\')\n    url=require(\'socket.url\')\n\n    sim.test(\'sim.mergeEvents\',true)\n    sim.test(\'sim.cborEvents\',true)\n\n    sim.addLog(sim.verbosity_scriptinfos,\'e.g. in your local web browser, type: https://127.0.0.1:\'..tostring(wsPort))\nend\n\nfunction sysCall_addOnScriptSuspend()\n    return {cmd=\'cleanup\'}\nend\n\nfunction sysCall_event(data)\n    sendEventRaw(data)\nend\n\nfunction sysCall_cleanup()\n    if wsServer then\n        simWS.stop(wsServer)\n    end\nend\n\nfunction getFileContents(path)\n    local f,err,errno=io.open(path,"rb")\n    if f then\n        local content=f:read("*all")\n        f:close()\n        return 200,content\n    else\n        return 404,nil\n    end\nend\n\nfunction onWSOpen(server,connection)\n    if server==wsServer then\n        wsClients[connection]=1\n        sendEventRaw(sim.getGenesisEvents(),connection)\n    end\nend\n\nfunction onWSClose(server,connection)\n    if server==wsServer then\n        wsClients[connection]=nil\n    end\nend\n\nfunction onWSMessage(server,connection,message)\nend\n\nfunction onWSHTTP(server,connection,resource,data)\n    resource=url.unescape(resource)\n    local mainPage=\'threejsFrontend\'\n    local status,data=404,nil\n    if resource==\'/\' or resource==\'/\'..mainPage..\'.html\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.html\')\n        if status==200 then\n            data=string.gsub(data,\'const wsPort = 23020;\',\'const wsPort = \'..wsPort..\';\')\n        end\n    elseif resource==\'/\'..mainPage..\'.js\' then\n        status,data=getFileContents(resourcesDir..\'/\'..mainPage..\'.js\')\n    elseif resource:sub(1,10)==\'/3rdparty/\' then\n        status,data=getFileContents(resourcesDir..resource)\n    end\n    if status==404 and resource~=\'/favicon.ico\' then\n        sim.addLog(sim.verbosity_errors,\'resource not found: \'..resource)\n    end\n    return status,data\nend\n\nfunction sendEventRaw(d,conn)\n    if d==nil then return end\n\n    if wsServer then\n        for connection,_ in pairs(wsClients) do\n            if conn==nil or conn==connection then\n                simWS.send(wsServer,connection,d,simWS.opcode.binary)\n            end\n        end\n    end\nend\n\nfunction verbose()\n    return sim.getNamedInt32Param(\'visualizationStream.verbose\') or 0\nend\n', 'tags': '', 'url': 'Coppeliasim.html'}, {'title': 'WebSocket', 'text': '希望能讓 CoppeliaSim 的 Visualization stream 在 https 運作 \n 使用 Stunnel 可以將 23020 轉向 443, 只要提供 self-signed certification 就可以. \n 但是其中的雙向資料是透過 ws:// websocket protocol 進行傳送, 因此必須處理為 wss:// 才可以與 https 結合運作. \n \n 有關 Websocket protocol 運作原理: \n WebSocket是一種在 Web瀏覽器和網頁伺服器之間提供全雙工通訊通道的協議 。WebSocket協議允許網頁使用一個單一的TCP連接來進行全雙工通訊，以取代傳統的HTTP請求/響應模型，可以更快地傳輸數據，減少延遲。 \n WebSocket的運作原理如下： \n 1. 首先，客戶端發起一個WebSocket請求，這個請求類似於HTTP請求，但是使用的是特殊的WebSocket URL格式，例如：ws://example.com/chat。(因此目前的重點是讓 客戶端發出的 WebSocket 採 https 傳送 ) \n 2. 伺服器接收到請求後，會回應一個HTTP 101切換協議的狀態碼，表示伺服器同意切換到WebSocket協議。( 要確定 SimAddonVisualization stream.lua 就是網頁伺服器, 而瀏覽器端的 client 則是 threejsFrontend.js ) \n 3. 接下來，客戶端和伺服器之間的通訊通道就建立了。雙方可以開始互相發送消息，並且可以隨時中斷連接。 \n 4. WebSocket協議通訊過程中，雙方可以直接傳送二進位數據，而不需要像HTTP一樣需要轉換成文本格式。 \n 5. 最後，當一方決定關閉WebSocket連接時，會向對方發送一個關閉封包。對方接收到關閉封包後，會回應一個關閉確認封包，然後關閉連接。 \n 總體來說，WebSocket協議的運作原理就是通過建立一個全雙工通訊通道，實現網頁與伺服器之間的實時數據通訊。 \n 在 CoppeliaSim 4.3.0 版本中，CoppeliaSim 提供了視覺化串流（Visualization stream）功能，它可以將 CoppeliaSim 中的 3D 串流資料傳輸到外部應用程式中，例如網頁瀏覽器。其中，"SimAddonVisualization stream.lua" 就是 CoppeliaSim 中的 Web 伺服器，負責將串流資料推送到網路中，而 threejsFrontend.js 則是網頁瀏覽器端的客戶端程式，負責接收來自 CoppeliaSim的串流資料，解讀並建立 3D 場景。 \n simExtWS.dll 庫負責建立 WebSocket 伺服器，並將 3D 場景串流資料推送到 WebSocket 客戶端，而simAddOnVisualizationStream.lua 程式則負責控制 WebSocket 服務器的啟動、停止和傳輸串流資料的內容。threejsFrontend.js 則是網頁瀏覽器端的客戶端程式，負責接收來自 CoppeliaSim 的串流資料，解讀場景中的元件後 ， 利用 three.js 建立出瀏覽器中的 3D 場景。 \n 為了讓 simAddonViaualization stream.lua 能在 SSL 模式下運作, 需要 \n lua 5.3.5 版解譯器適用的 luasec 或 luassl: \n https://github.com/brunoos/luasec \xa0 \n https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Windows \xa0 \n https://luabinaries.sourceforge.net/download.html \xa0', 'tags': '', 'url': 'WebSocket.html'}, {'title': '瀏覽器串流', 'text': '\n 以下設定適用於 CoppeliaSim 採 https 檢視瀏覽器上的場景串流. \n stunnel.conf 檔案設定: \n 將 http 原先在 port 23020 的連線指向 https 外部 IP, 意即 server 的 SSL/TLS 在外部 IP 位址的 443 port 中, 而 隨後的 WebSocket client 要建立 wss:// 雙向連結時, 必須指向外部 IP address 中的 port 443 . \n [https]\naccept =140.130.17.108:443\nconnect = 127.0.0.1:23020\ncert = c:\\tmp\\localhost.crt\nkey = c:\\tmp\\localhost.key \n threejsFrontend.html 中: \n 因為 client 要以 wss:// 建立雙向連線, 必須指令 https 對應的 port, 也就是 443 . \n <script>\n    const wsPort = 443;\n    const codec = "cbor";\n</script> \n simAddonVisualization stream.lua 中: \n Server 內部由 Modules -> Connectivity -> Visualization Stream 時就是執行  simAddonVisualization stream.lua 啟動時以內建的 http port 23020 啟動 , 也就是 stunnel 設定中的 connect 伺服器封包來源, 經由 stunnel 後, 則以外部 IP address 從 443 port 讓 wss:// WebSocket 連線提出 requests. \n     wsPort=sim.getNamedInt32Param(\'visualizationStream.ws.port\') or 23020\n    sim.addLog(sim.verbosity_scriptinfos,\'WS endpoint on port \'..tostring(wsPort)..\'...\')\n    if sim.getNamedBoolParam(\'visualizationStream.ws.retryOnStartFailure\') then\n        while true do\n            local r,e=pcall(function() wsServer=simWS.start(wsPort) end)\n            if r then break end\n            sim.addLog(sim.verbosity_scriptwarnings,\'WS failed to start (\'..e..\'). Retrying...\')\n            sim.wait(0.5,false)\n        end\n    else\n        wsServer=simWS.start(wsPort)\n    end \n threejsFrontend.js 中: \n 這是  client 端擬以 wss:// 提出 requests, 必須將連線指向外部 IP 位址的 port 443 \n class VisualizationStreamClient {\n    constructor(host = \'140.130.17.108\', port = 443, codec = \'cbor\') {\n        this.host = host;\n        this.port = port;\n        this.codec = codec;\n        this.websocket = new ReconnectingWebSocket(`wss://${this.host}:${this.port}`); \n 同樣在 threejsFrontend.js 中 line 3127: \n // original port is 23050 Yen changed to 443\nvar remoteApiClient = new RemoteAPIClient(window.location.hostname, 443, \'cbor\', {createWebSocket: url => new ReconnectingWebSocket(url)});\n \n RemoteAPIclient.js 中: \n 這也是  WebSocket client 端, 以 wss:// 提出 requests, 必須將連線指向外部 IP 位址的 port 443 \n class RemoteAPIClient {\n    constructor(host = \'140.130.17.108\', port = 443, codec = "cbor", opts = {}) {\n        this.host = host;\n        this.port = port;\n        this.codec = codec;\n        var packMessage;\n        var unpackMessage;\n        if(this.codec == \'cbor\') {\n            //this.websocket.binaryType = "arraybuffer";\n            packMessage = data => CBOR.encode(data);\n            unpackMessage = async data => CBOR.decode(await data.arrayBuffer());\n        } else if(this.codec == "json") {\n            packMessage = data => JSON.stringify(data);\n            unpackMessage = data => JSON.parse(data);\n        }\n        var wsOpts = {\n            packMessage,\n            unpackMessage,\n            // attach requestId to message as `id` field\n            attachRequestId: (data, requestId) => Object.assign({id: requestId}, data),\n            // read requestId from message `id` field\n            extractRequestId: data => data && data.id,\n        };\n        for(var k in opts)\n            wsOpts[k] = opts[k];\n        this.websocket = new WebSocketAsPromised(`wss://${this.host}:${this.port}`, wsOpts);\n    } \n simAddOnWS remote API server.lua 中 line 107 : \n -- original port is 23050 Yen changes to 443\nport=sim.getNamedInt32Param(\'wsRemoteApi.port\') or 443 \n', 'tags': '', 'url': '瀏覽器串流.html'}, {'title': 'copsim', 'text': "準備在 151 建立 copsim.cycu.org 10ff:151::1 \n https://forum.coppeliarobotics.com/viewtopic.php?t=9294 \xa0 \n https://coppeliarobotics.com/helpFiles/en/dataVisualizationAndOutput.htm \xa0 \n 能否在 headless 啟動 Visualization Stream function and open scene throught programming? \n Reference: \n You can start CoppeliaSim passing the command line parameter -GzmqRemoteApi.rpcPort=23005. \n Or with CoppeliaSim already started, execute sim.setNamedInt32Param('zmqRemoteApi.rpcPort',23005) (e.g. in the lua commander at bottom of screen) and then restart the ZMQ Remote API server addon. \n 若將 simAddonVisualization stream.lua 中的 autoStart 設為 true, 則 Coppeliasim 啟動後將自動執行 Visualization stream server. \n 且若以\xa0coppeliasim -h -s c:\\tmp\\mtb_robot.ttt 指定採 headless 方式啟動 (-h), 且自動執行 simulation (-s), 則可將此一指令設為 service 讓場景的執行隨操作系統啟動. \n simAddOZMQ remoteAPI server.lua 中修改: \n function zmqRemoteApi.verbose()\n    -- return tonumber(sim.getStringNamedParam('zmqRemoteApi.verbose') or '0')\n    -- set zmqRemoteApi server autoStart = true\n    return tonumber(sim.getStringNamedParam('zmqRemoteApi.verbose') or '1')\nend \n 可讓 zmqRemoteAPI 隨系統啟動.", 'tags': '', 'url': 'copsim.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex2', 'text': 'This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5. \n \n \n \n \n \n \n Solve ODE: \n from browser import document\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new paragraph element and set its text content to the solution\np = document.createElement(\'p\')\np.textContent = f"The solution to the ODE is: {y}"\n\n# Append the paragraph element to the body of the webpage\ndocument.body.appendChild(p) \n \n \n \n \n \n Brython environment and  Plotly.js : \n <script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\']});\n}\n// ]]></script>\n<p id="brython_div"></p> \n Brython programe with Plotly.js: \n from browser import document, window\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new div element to hold the plot\n#plot_div = document.createElement(\'div\')\n#plot_div.id = \'plot\'\n#document.body.appendChild(plot_div)\nplot_div = document["brython_div"]\n\n# Plot the solution using plotly.js\ndata = [{\'x\': x, \'y\': y}]\nwindow.Plotly.newPlot(\'brython_div\', data) \n This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using  plotly.js . \n \n \n \n \n This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using  plotly.js . \n \n \n \n \n \n \n \n \n \n \n \n \n \n STL part viewer \n \n \n \n \n Using  sine-cosine algorithm  to optimize with constraints in Brython: \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n Plot the result by using  plotly.js : \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n<div id="plot"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n\n# Plot the result using Plotly.js\ndata = [\n    {\n        \'x\': [best_solution[0]],\n        \'y\': [best_solution[1]],\n        \'mode\': \'markers\',\n        \'marker\': {\'size\': 12},\n        \'name\': \'Best Solution\'\n    }\n]\n\nlayout = {\n    \'xaxis\': {\'range\': [-10, 10]},\n    \'yaxis\': {\'range\': [-10, 10]},\n}\n\nPlotly.newPlot(\'plot\', data, layout)\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n', 'tags': '', 'url': 'Brython_ex2.html'}]};